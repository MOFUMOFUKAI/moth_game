<!DOCTYPE html> 
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="icn_mothvoid.png">
  <title>MOTHVOID</title>
  <style>
    * {
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      user-select: none;
    }
    body {
      margin: 0;
      background: #000;
      color: white;
      font-family: monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;  /* ← 縦方向いっぱいに使う */
      overflow: hidden;
    }
    img, button {
      -webkit-user-drag: none;
      user-select: none;
      -webkit-touch-callout: none;
    }
    #titleScreen {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 10;
    }
    #titleLogo {
      width: 380px;
      margin-bottom: 20px;
    }
    #pressToStart {
      font-size: 20px;
      color: #FFD700;
      animation: blink 2s infinite;
      font-family: 'monospace';
    }
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }
    #time {
      display: none;
    }
    #game {
      position: relative;
      width: 100vw;
      height: 150vw;
      max-width: 400px;
      max-height: 600px;
      margin-top: -2px; /* ← この1行を追加 */
      background: #111;
      border: 2px solid #fff;
      overflow: hidden;
      margin: -80px auto 0; /* ← 上に30px寄せる */
      z-index: 0; 
    }
    #player {
      position: absolute;
      width: 48px;
      height: 48px;
      bottom: 10px;
      left: 180px;
      background-image: url("chr_moth.gif");
      background-size: cover;
      z-index: 2;
    }
    #hitbox {
      position: absolute;
      width: 35px;
      height: 35px;
      bottom: 12px;
      left: 182px;
      pointer-events: none;
      z-index: 2;
    }
    .obstacle {
      position: absolute;
      width: 50px;
      height: 50px;
      background: red;
      z-index: 2;
    }
    .obstacle.stage4 {
      background-color: #555;
    }
    .afterimage {
      position: absolute;
      width: 40px;
      height: 40px;
      pointer-events: none;
      z-index: 2;
      animation: fade .1s forwards;
    }
    .afterimage::after {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, rgba(0, 200, 255, 0.4) 0%, rgba(0, 200, 255, 0.0) 80%);
      border-radius: 50%;
      box-shadow: 0 0 15px rgba(0, 200, 255, 0.3);
      top: 0;
      left: 0;
      pointer-events: none;
    }
    @keyframes fade {
      to { opacity: 0; }
    }
    .dodge-flare {
      position: absolute;
      width: 40px;
      height: 40px;
      top: 0;
      left: 0;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(0, 200, 255, 0.4), rgba(0, 200, 255, 0));
      pointer-events: none;
      z-index: 1;
    }
    .heal {
      position: absolute;
      width: 40px;
      height: 40px;
      font-size: 28px;
      color: pink;
      text-align: center;
      line-height: 40px;
      pointer-events: none;
    }
    .explosion {
      position: absolute;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: radial-gradient(circle, orange, red, transparent);
      animation: explode 0.4s ease-out forwards;
      pointer-events: none;
    }
    .rainbow {
      animation: rainbow 0.5s infinite;
    }
    @keyframes explode {
     0% { opacity: 1; transform: scale(0.5); }
     100% { opacity: 0; transform: scale(2); }
    }
    @keyframes rainbow {
      0% { filter: hue-rotate(0deg); }
      100% { filter: hue-rotate(360deg); }
    }
    .damage-flash {
      animation: flashWhite 0.15s ease-in-out;
    }
    @keyframes flashWhite {
      0% { filter: brightness(1); }
      50% { filter: brightness(3); }
      100% { filter: brightness(1); }
    }
   /* スコア（白枠外） */
    #uiTop {
      position: relative; 
      width: 400px;
      margin-bottom: 80px;
      color: white;
      font-family: monospace;
    }
    #score {
      text-align: center;
      font-size: 20px;
      margin-bottom: 4px;
    }
   /* ハート（ライフ表示）レベル・経験値白枠内左上に表示 */
    #levelExpRow {
     position: absolute;
     top: 8px;
     right: 6px;
     font-size: 14px;
     z-index: 10;
    }
    #smartphoneHint {
     color: white;
     font-size: 0.85em;
     margin-top: 10px;
     line-height: 1.4;
    }
    #lives {
      position: absolute;
      top: 5px;
      left: 5px;
      font-size: 20px;
      z-index: 5;
    }
    #comboText {
      position: absolute;
    }
    #gameClear, #gameOver {
      position: absolute;
      left: 0;
      width: 100%;
      height: 100%;
      display: none;
      justify-content: center;
      align-items: flex-start;
      padding-top: 80px;
      text-align: center;
      color: yellow;
      background: rgba(0, 0, 0, 0.7);
      font-size: 20px;
      z-index: 20;
      pointer-events: none; 
    }
   #thankYouText {
     font-size: clamp(18px, 6vw, 32px);  /* ← 画面幅に応じて自動縮小 */
     margin-bottom: 10px;
     white-space: nowrap;
     overflow: hidden;
     text-overflow: ellipsis;
     max-width: 100%;
   }
    #timeRating {
      font-size: 30px;
      margin-bottom: 10px;
    }
    #credits {
      font-size: 16px;
    }
    #restartButton {
      display: none;
      position: absolute;
      left: 50%;
      bottom: 2%; /* ゲーム画面の中央に表示 */
      transform: translate(-50%, -50%);
      padding: 8px 16px;
      font-size: 16px;
      background-color: #f39c12;
      color: white;
      border: none;
      border-radius: 5px;
      z-index: 9999;               /* 重なり順を最前面に調整 */
      cursor: pointer;
      pointer-events: auto;       /* タッチを確実に受け付ける */
      touch-action: manipulation; /* ← タップ反応を最適化（特にiOS） */
    }
    #touchControls {
      display: flex;
      justify-content: space-between;
      align-items: flex-end;  /* ← 下揃えに変更 */
      width: 400px;
      margin-top: 42px;
      padding: 0 10px;
      height: 40px;  /* ← 高さを固定 */
      position: relative;
    }
    #moveInstruction,
    #parryInstruction {
      position: absolute;
      bottom: 65px; /* ← ボタンより上に固定表示 */
      font-size: 14px;
      color: #FFD700;
      font-family: monospace;
      text-align: center;
      width: 120px;
      white-space: nowrap;
    }
    #moveInstruction {
      left: 20px;
    }
    #parryInstruction {
      right: 60px;
    }
    .arrowGroup {
      display: flex;
      gap: 30px;
      margin-left: 30px; /* ← 矢印全体を右にずらす */
    }
    .parryGroup {
      display: flex;
      justify-content: flex-end;
    }

    .control-button {
      width: 60px;
      height: 60px;
    }
    #btnParry {
      margin-right: 70px; /* ← 右詰め調整 */
    }

    #screenFade {
      position: absolute;
      top: 0; left: 0;
      width: 400px;
      height: 600px;
      background: #000;
      pointer-events: none;
      opacity: 0;
      transition: opacity .75s ease;
      z-index: 9;
    }
    #background {
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      background-size: 100% auto;
      background-repeat: repeat-y;
      background-position-y: 0px;
      z-index: 0;
    }
    #bgDarkenLayer {
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      background-color: black;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.75s ease;
      z-index: 1;
    }
    .obstacle-img {
      position: absolute;
      pointer-events: none;
      transform: translate(-50%, -50%);
    }
    .score-popup {
      position: absolute;
      font-size: 18px;
      font-weight: bold;
      font-family: monospace;
      pointer-events: none;
      animation: floatUp 0.5s ease-out forwards;
      z-index: 100;
    }

    @keyframes floatUp {
      0% {
        opacity: 1;
        transform: translateY(0px);
      }
      100% {
        opacity: 0;
        transform: translateY(-30px);
      }
    }
    
    /* ▼ ポーズ／再開ボタンの配置・見た目 */
   #pauseControls {
     position: absolute;
     top: -3px;
     right: 20px;
     z-index: 15;
     display: flex;
     gap: 6px;
   }

   #pauseButton,
   #resumeButton {
     font-size: 18px;
     background: none;
     border: none;
     color: white;
     cursor: pointer;
     padding: 2px 6px;
   }

   /* ポーズ中に中央に表示されるPAUSEテキスト */
   #pauseOverlay {
     position: absolute;
     top: 50%;
     left: 50%;
     transform: translate(-50%, -50%);
     font-size: 36px;
     color: white;
     background: rgba(0, 0, 0, 0.6);
     padding: 10px 30px;
     border-radius: 10px;
     display: none;
     z-index: 999;
     pointer-events: none;
   }

  .void-rank {
    font-size: 28px;
    color: gold;
    text-shadow: 0 0 10px gold, 0 0 20px orange;
    font-weight: bold;
    animation: glow 1.5s infinite alternate;
  }

  .void-subtext {
    font-size: 14px;
    color: #ccc;
    margin-top: 5px;
  }

  @keyframes glow {
    from { text-shadow: 0 0 5px gold; }
    to { text-shadow: 0 0 20px gold, 0 0 30px orange; }
  }
  
#voidFeathers {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 9999;
}
.invincible-orb {
  position: absolute;
  width: 12px;
  height: 12px;
  background: purple;
  border-radius: 50%;
  pointer-events: none;
  z-index: 5;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  animation: rotateAround 1s linear infinite;
}
.orb1 { animation-delay: 0s; }
.orb2 { animation-delay: 0.5s; }

@keyframes rotateAround {
  0% {
    transform: translate(-50%, -50%) rotate(0deg) translateX(30px) rotate(0deg);
  }
  100% {
    transform: translate(-50%, -50%) rotate(360deg) translateX(30px) rotate(-360deg);
  }
}

.feather {
  position: absolute;
  width: 24px;
  height: 24px;
  background-image: url('eff_feather.png');
  background-size: cover;
  opacity: 1;
  z-index: 99999;
  pointer-events: none;
  transform: translate(0, 0) rotate(0deg);
  animation: featherFly var(--flyTime, 2s) ease-out forwards,
             featherWobble 3s ease-in-out infinite;
            
}

@keyframes featherFly {
  0% {
    transform: translate(0px, 0px) rotate(var(--startAngle));
    opacity: 1;
  }
  10% {
    transform: translate(calc(var(--dx) * 1px), calc(var(--dy) * 0.3px)) rotate(var(--midAngle));
    opacity: 1;
  }
  100% {
    transform: translate(calc(var(--dx) * 1px), calc(var(--dy) * 1px)) rotate(var(--endAngle));
    opacity: 0;
  }
}
@keyframes featherWobble {
  0%, 100% {
    filter: brightness(1.8);
  }
  50% {
    filter: brightness(2.3);
  }
}

  </style>
</head>
<body>
<!-- UIエリア（スコア） → 白枠の外、画面中央上 -->
<div id="uiTop">
  <div id="score">スコア: 0</div>
  <div id="musicTitle" style="
  position: absolute;
  top: 530px;
  left: 50%;
  transform: translateX(-50%);
  color: white;
  font-size: 16px;
  font-family: monospace;
  text-shadow: 0 0 6px black;
  opacity: 0;
  transition: opacity 0.5s ease;
  z-index: 10;
  pointer-events: none;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 90vw;
"></div>
   <!-- ポーズ／再開ボタン（右上） -->
  <div id="pauseControls">
    <button id="pauseButton" title="ポーズ">⏸</button>
    <button id="resumeButton" title="再開" style="display: none;">▶️</button>
  </div>
</div>
<!-- タイム表示（デバッグ用など） -->
<div id="time" style="display: none;">タイム: 0.000秒</div>

<!-- タイトル画面 -->
<div id="titleScreen">
<!-- HIGH SCORE 見出しを追加 -->
  <div style="font-size: 16px; font-weight: bold; margin-bottom: 4px; color: #FFD700;">HIGH SCORE</div>
<!-- タイトル画面のスコア表示領域（タイトルロゴの上など） -->
  <div id="topHighScore" style="font-size: 14px; margin: 5px auto 0 auto; text-align: center;"></div>
  <img src="title_mothvoid.webp" alt="MOTHVOIDタイトルロゴ" id="titleLogo">
  <p id="pressToStart">PRESS ANY BUTTON</p>
  <p id="smartphoneHint" class="title-only">
  Ver.1.2.4<br>
  ※スマホの場合<br>
  「共有ボタン→ホーム画面に追加」<br>
  その後ホーム画面のショートカットから<br>
  プレイするのがおススメ！<br>
  ※iOS 15以上（iPhone / iPad）<br>
  ※Safari/Chromeは最新版を使用してください
  
</p>
</div>

<!-- ゲーム画面 -->
<div id="game">
 <!-- Vランク羽根演出 -->
  <div id="voidFeathers" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:99999;"></div>
  <div id="background"></div>
  <div id="bgDarkenLayer"></div>
  <div id="player"></div>
  <div id="hitbox"></div>
  <div id="lives">❤️❤️❤️</div>
  <div id="screenFade"></div>
   <!-- レベル／経験値表示（白枠右上） -->
  <div id="levelExpRow">
    <span id="level">Lv.1</span>
    <span id="exp">EXP: 0 / 200</span>
  </div>
  
  <!-- ポーズ中の表示 -->
  <div id="pauseOverlay">PAUSE</div>
  
  <!-- エフェクト -->
    <img id="justParryEffect" src="eff_just_parry.gif"
       style="display: none; position: absolute; width: 60px; height: 60px; z-index: 3; pointer-events: none;">
    <!-- BGM -->
    <audio id="bgm_stage1" loop><source src="bgm_stage1.mp3" type="audio/mpeg"></audio>
    <audio id="bgm_stage2" loop><source src="bgm_stage2.mp3" type="audio/mpeg"></audio>
    <audio id="bgm_stage3" loop><source src="bgm_stage3.mp3" type="audio/mpeg"></audio>
    <audio id="bgm_final" loop><source src="bgm_final.mp3" type="audio/mpeg"></audio>
    <audio id="bgm_final2" loop><source src="bgm_final2.mp3" type="audio/mpeg"></audio>
    <audio id="bgm_result" loop>  <source src="bgm_result.mp3" type="audio/mpeg"></audio>
    <!-- SE -->
    <audio id="seParry"><source src="se_parry.mp3" type="audio/mpeg"></audio>
    <audio id="seDodge"><source src="se_dodge.mp3" type="audio/mpeg"></audio>
    <audio id="seBombL"><source src="se_bomb_L.mp3" type="audio/mpeg"></audio>
    <audio id="seItem"><source src="se_item.mp3" type="audio/mpeg"></audio>
    <audio id="seJustParry"><source src="se_justparry.mp3" type="audio/mpeg"></audio>
    <!-- クリア画面 -->
    <div id="gameClear">
     <div>
        <h2 id="thankYouText">Thank you for playing!</h2>
        <p id="timeRating"></p>
        <p id="credits">
          <span>Director: akky</span><br>
          <span>Designer: MAS</span><br>
          <span>Programmer: GPT</span><br>
          <span>MOTHVOID 2025/7/01</span>
        </p>
        
        <!-- ✅ ランキング表示 -->
        <div id="scoreList" style="margin-top: 14px; font-size: 16px;"></div>
    
      </div>
    </div>

    <!-- ゲームオーバー画面 -->
    <div id="gameOver">
      <h2>Game Over</h2>
    </div>
    <!-- 再プレイボタン -->
    <button id="restartButton">再プレイ</button>
  </div> <!-- ← #game の閉じタグ -->
  
    <!-- ▼ ハイスコア名前入力UI（初期は非表示） -->
    <div id="nameEntryScreen" style="display:none; position:absolute; top:0; left:0; width:100%; height:100%; background:#000d; color:white; z-index:999; display:flex; flex-direction:column; align-items:center; justify-content:center;">
      <div style="font-size:20px; margin-bottom:10px;">HIGH SCORE! ENTER YOUR NAME</div>
      <div id="nameEntry" style="font-size:36px; letter-spacing:10px;">A A A A</div>
      <div style="margin-top:20px;">
        <button onclick="prevChar()">◀</button>
        <button onclick="nextChar()">▶</button>
        <button onclick="goBackChar()" id="backButton" style="margin-left: 20px;">前へ</button> <!-- ✅ 新しく追加 -->
        <button onclick="confirmNameEntry()" id="confirmButton" style="margin-left: 20px;">次へ</button>
      </div>
    </div>
    
    <!-- タッチ操作ボタン -->
<div id="touchControls" class="title-only">
  <div class="arrowGroup">
    <div id="moveInstruction" class="instruction title-only">左右移動／連続入力で回避</div>
    <img id="btnLeft" src="btn_left.png" class="control-button">
    <img id="btnRight" src="btn_right.png" class="control-button">
  </div>
  <div class="parryGroup">
    <div id="parryInstruction" class="instruction title-only">パリィ／ジャストパリィ</div>
    <img id="btnParry" src="btn_parry.png" class="control-button">
  </div>
 <script>
 /* =======================================================
   ▼ ゲーム定数・設定値
   ======================================================= */
  const game = document.getElementById("game");
  const player = document.getElementById("player");
  const hitbox = document.getElementById("hitbox");
  const scoreEl = document.getElementById("score");
  const livesEl = document.getElementById("lives");
  const timeEl = document.getElementById("time");
  const levelEl = document.getElementById("level");
  const maxLevel = 7; 
  const expEl = document.getElementById("exp");
  const normalParryRadius = 56;
  const PARRY_COOLDOWN = 400; // クールダウン時間 [ms]
  const maxGauge = 3;
  const gameClear = document.getElementById("gameClear");
  const scrollDuration = 120; // 背景スクロール速度（秒）
  const timeRatingEl = document.getElementById("timeRating");
  const restartButton = document.getElementById("restartButton");
  const seParry = document.getElementById("seParry");
  const seBombL = document.getElementById("seBombL");
  const seDodge = document.getElementById("seDodge");
  const seItem = document.getElementById("seItem");
  const seJustParry = document.getElementById("seJustParry");
  const allObstacles = [];
  const btnLeft  = document.getElementById("btnLeft");
  const btnRight = document.getElementById("btnRight");
  const btnParry = document.getElementById("btnParry");
  const titleScreen = document.getElementById("titleScreen");
  const availableChars = [..."ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_.!*@#?<> "];
    // ▼ ハイスコア保存用ロジック（localStorage使用）
  const HIGH_SCORE_KEY = "yamamayu_high_scores";
  const defaultHighScores = [
    { name: "MOTH", score: 400000, rating: "SS" },
    { name: "LMNG", score: 350000, rating: "S" },
    { name: "KAIK", score: 300000, rating: "A" },
    { name: "YMMY", score: 250000, rating: "B" },
    { name: "OOMZ", score: 200000, rating: "C" }
  ];
  const bgm = {
     Stage1: document.getElementById("bgm_stage1"),
     Stage2: document.getElementById("bgm_stage2"),
     Stage3: document.getElementById("bgm_stage3"),
     Final:  document.getElementById("bgm_final"),
     Final2: document.getElementById("bgm_final2"),
     Result: document.getElementById("bgm_result")
   };
  
 /* =======================================================
    ▼ ゲーム進行状態（変化する値）
   ======================================================= */
  let score = 0;
  let lives = 3;
  let maxLives = 3;
  let gameOver = false;
  let invincible = false;
  let parryActive = false;
  let justParry = false;
  let playerX = 180;
  let playerSpeed = 3;
  let obstacleSpeed = 15;  // 障害物の速度
  let startTime = Date.now();  // ゲーム開始時の時間
  let gameTime = 0;  // 経過時間（ミリ秒）
  let obstacleGenerationInterval;
  let scoreUpdateInterval;
  let timeUpdateInterval;
  let lastScoreUpdateTime = 0;  // 最後にスコアを更新したミリ秒
  let highScore = localStorage.getItem("highScore") || 0;
  let justParryRadius = 40;  // Lv.1 初期値（最大52まで上昇）
  let parryGauge = 0; 
  let level = 1;
  let exp = 0;
  let stage = 1;
  let lastParryTime   = 0;   // 前回パリィを打ったタイムスタンプ
  let firstInteraction = false;
  let currentBGM = null;
  let gameStarted = false;
  let gamePaused = false;
  let baseInterval   = 800;  // ★ 現在の間隔（初期 800ms）
  let obstacleTimerId      = null; // ★ setInterval の ID を保持
  let obstacleSpawnInterval = null;
  let itemFallTimers = []; // 💡 すべての落下アイテムの fall ID をここに記録
  let isPaused = false;
  let pauseStart = 0;
  let totalPausedTime = 0;
  let superInvincible = false;
  let orb1, orb2;
  let lastKey        = "";      // 直前の方向キー
  let lastKeyTime    = 0;       // 押下タイムスタンプ
  let isDodging      = false;   // 回避モーション中
  let speedBoost     = false;   // 回避後 0.3 s だけ 2 倍速
  let keyPressed = {};  // 押下中かどうか
  let pausedDueToVisibility = false; // タブ非表示による一時停止かどうか
  let lastExplosionTime = 0;
  let isTouchHolding = false;
  let touchHoldInterval = null;
  // ==== Combo System Globals ====
  let currentComboCount = 0;        // 今のヒット数（2以上から）
  let comboInProgress = false;      // コンボ中か
  let comboLastUpdateTime = 0;      // 最後のヒット時刻（ミリ秒）
  let comboReflectedCount = 0;      // 現在アクティブな反射弾の数
  let comboBonusGiven = false;      // ボーナスが既に表示されたか
  let comboWatcherStarted = false;  // ✅ ← これを忘れずに追加
  let comboEndTimeout = null;
  
  // ハイスコア取得
  function loadHighScores() {
    const json = localStorage.getItem(HIGH_SCORE_KEY);
    return json ? JSON.parse(json) : defaultHighScores;
  }

  // ハイスコア保存
  function saveHighScores(highScores) {
    localStorage.setItem(HIGH_SCORE_KEY, JSON.stringify(highScores));
  }

  // 現在のハイスコア（5件以内）を保持
  let highScores = loadHighScores();
  let enteringName = false;
  let nameChars = ["A", "A", "A", "A"];
  let namePos = 0;

  const ratingCoefficients = {
    "V": 4.0,
    "SS": 3.6,
    "S": 3.2,
    "A": 2.8,
    "B": 2.4,
    "C": 2.0,
    "D": 1.6,
    "E": 1.2
  };

  const DOUBLE_TAP_MS = 200;    // 0.2 秒以内
  const STEP_PX       = 30;     // 1 ステップ距離
  
  window.addEventListener("load", () => {
    if (bgm["stage1"]) bgm["stage1"].load(); // 読み込みだけしておく
  });
/* =======================================================
   ▼ ゲーム開始／再スタート処理（BGMフェードイン対応）
   ======================================================= */
function fadeInBGM(audio, duration = 1000) {
  const target = parseFloat(audio.dataset.targetVolume || 1);
  audio.volume = 0;
  audio.currentTime = 0;

  // ✅ ここですぐ currentBGM を確定する
  currentBGM = audio;

  audio.play().catch(e => {
    console.warn("🔇 BGM fade-in failed:", e);
  });

  const step = target / (duration / 50);
  let n = 0;
  const id = setInterval(() => {
    n++;
    audio.volume = Math.min(target, audio.volume + step);
    if (audio.volume >= target || n >= (duration / 50)) {
      clearInterval(id);
    }
  }, 50);
}

/* =======================================================
   ▼ BGM クロスフェード ユーティリティ
   ======================================================= */
function crossfadeBGM(fromAudio, toAudio, duration = 1500) {
  if (!fromAudio || !toAudio || fromAudio === toAudio) return;

  const fromTarget = 0;
  const toTarget = parseFloat(toAudio.dataset.targetVolume || 1);

  const stepTime = 50;
  const steps = duration / stepTime;
  const fromStep = (fromAudio.volume - fromTarget) / steps;
  const toStep = toTarget / steps;

  toAudio.volume = 0;
  toAudio.currentTime = 0;

  toAudio.play().catch(e => {
    console.warn("🔇 crossfadeBGM: play failed", e);
  });

  let n = 0;
  const id = setInterval(() => {
    n++;
    fromAudio.volume = Math.max(fromTarget, fromAudio.volume - fromStep);
    toAudio.volume = Math.min(toTarget, toAudio.volume + toStep);

    if (n >= steps) {
      clearInterval(id);
      fromAudio.pause();
      fromAudio.volume = parseFloat(fromAudio.dataset.targetVolume || 1);
    }
  }, stepTime);
}

/* =======================================================
   ▼ 曲名表示
   ======================================================= */
function showMusicTitle(text) {
  const titleEl = document.getElementById("musicTitle");
  titleEl.textContent = text;
  titleEl.style.opacity = 1;

  setTimeout(() => {
    titleEl.style.opacity = 0;
  }, 5000);
}
/* =======================================================
   ▼ 背景スクロール速度
   ======================================================= */
let backgroundOffset = 0;
let scrollSpeed = 0.2; // ステージごとに変化する基本速度（初期値）

function scrollBackground() {
  // スコアに応じた加速処理
  let extraSpeed = 0;
  if (score >= 300000) {
    const steps = Math.floor((score - 300000) / 150000) + 1;
    extraSpeed = Math.min(steps, 7); // 最大加速は +7.0 まで
  }

  // 背景スクロール処理
  backgroundOffset += scrollSpeed + extraSpeed;
  const bg = document.getElementById("background");
  if (bg) {
    bg.style.backgroundPositionY = `${backgroundOffset}px`;
  }

  requestAnimationFrame(scrollBackground);
}

// ステージごとの基本スクロール速度を設定（ゲーム開始・進行時に呼び出し）
function setStageBackgroundSpeed(stage) {
  if (stage === 1) scrollSpeed = 0.3;
  else if (stage === 2) scrollSpeed = 0.5;
  else if (stage === 3) scrollSpeed = 0.8;
  else if (stage === 4) scrollSpeed = 2.0;
  else if (stage === 5) scrollSpeed = 2.0; // ステージ4と同じ速度を維持
}

/* =======================================================
   ▼ 背景 クロスフェード付きステージ管理
   ======================================================= */

/** 背景‐BGM クロスフェードの所要時間（ms） */
const FADE_MS = 1500;          // ←BGM の crossfadeBGM() と揃えています

/**
 * 暗転 → 背景画像切替 → 明転
 * @param {number} nextStage 1〜5
 */
function crossfadeBackground(nextStage){
  const bg    = document.getElementById("background");
  const darken = document.getElementById("bgDarkenLayer");

  // 暗くする
  darken.style.opacity = 1;

  setTimeout(() => {
    // 背景画像切替（暗いまま切り替え）
    bg.style.backgroundImage = `url(env_stage${nextStage}.webp)`;

    // 明るく戻す
    darken.style.opacity = 0;
  }, FADE_MS / 2);
}

/* =======================================================
   ▼ 背景情報更新
   ======================================================= */
function updateBackgroundInstant(stageNum) {
  const bg = document.getElementById("background");

  // 背景画像を即時切替
  bg.style.backgroundImage = `url(env_stage${stageNum}.webp)`; // 例: env_stage2.webp

  // 必要な初期スタイル再設定（念のためリセット）
  bg.style.backgroundRepeat = "repeat-y";
  bg.style.backgroundSize = "100% auto";
  bg.style.backgroundPositionY = `${backgroundOffset}px`; // スクロール位置に合わせる
}
/* ──────────────────────────────────────────────
     ステージ判定 &  ビジュアル/BGM 同期クロスフェード
   ────────────────────────────────────────────── */
function checkStage() {
  const prevStage = stage;

  // スコアに応じたステージ更新
  stage =
    score >= 600000 ? 5 :
    score >= 150000 ? 4 :
    score >= 100000 ? 3 :
    score >=  50000 ? 2 : 1;

  if (stage !== prevStage) {
    crossfadeBackground(stage);
    setStageBackgroundSpeed(stage);

    const newBGM =
      stage === 5 ? bgm.Final2 :
      [bgm.Stage1, bgm.Stage2, bgm.Stage3, bgm.Final][stage - 1];

    const oldBGM = currentBGM; // ← 旧曲を一時保存

    // 曲が変わっていればクロスフェード、初回や同一なら fadeIn
    if (oldBGM && oldBGM !== newBGM && !oldBGM.paused && oldBGM.currentTime > 0) {
      crossfadeBGM(oldBGM, newBGM, FADE_MS);
    } else {
      fadeInBGM(newBGM, FADE_MS);
    }

    currentBGM = newBGM; // 最後に更新！

    const musicTitles = {
      1: "♪Starlight Vanguard",
      2: "♪Brave Ascent",
      3: "♪Voidborne Resolve",
      4: "♪Burn the Void",
      5: "♪Beyond the Edge"
    };
    showMusicTitle(musicTitles[stage]);
  }
}

window.addEventListener("DOMContentLoaded", () => {
  document.getElementById("nameEntryScreen").style.display = "none";
  enteringName = false;
  window.newHighScore = null;

  displayTopHighScore();
});
/* =======================================================
   ▼ メインゲーム開始処理
   ======================================================= */
function startGame() {
  if (enteringName) return; // ← ハイスコア名入力中なら無効化
  if (!gameOver && firstInteraction) return;
  firstInteraction = true;

  // タイトル画面非表示
  const titleScreen = document.getElementById("titleScreen");
  displayTopHighScore(); // ← 先に表示する（非表示にする前！）
  if (titleScreen) {
    titleScreen.style.display = "none";
    document.getElementById("moveInstruction").style.display = "none";
    document.getElementById("parryInstruction").style.display = "none";
  }

  allObstacles.forEach(obj => obj.remove());
  allObstacles.length = 0;
  scrollBackground();

  /* ★★★★★ ここから音量プリセット ★★★★★ */
  const BGM_VOLUME = 0.8;
  const SE_VOLUME  = 0.8;

  [seParry, seDodge, seBombL, seItem, seJustParry].forEach(se => se.volume = SE_VOLUME);

  [bgm.Stage1, bgm.Stage2, bgm.Stage3, bgm.Final, bgm.Final2, bgm.Result].forEach(bgm => {
    bgm.dataset.targetVolume = BGM_VOLUME;
  });
  /* ★★★★★ ここまで音量プリセット ★★★★★ */

  // スクロール速度とオフセット・レベル・経験値などを初期化
  level = 1;
  exp = 0;
  maxLives = 3;
  lives = maxLives;
  playerSpeed = 3;
  scrollSpeed = 0.3;
  backgroundOffset = 0;

  setStageBackgroundSpeed(1);
  updateBackgroundInstant(1);

  // 変数初期化
  gameOver = false;
  gameStarted = true; 
  score = 0;
  parryGauge = 0;
  startTime = Date.now();
  lastScoreUpdateTime = 0;
  gameTime = 0;
  resetObstacleSpawn();

  // BGM 初期化と再生
  [bgm.Stage1, bgm.Stage2, bgm.Stage3, bgm.Final, bgm.Final2, bgm.Result].forEach(bgm => {
    bgm.pause();
    bgm.currentTime = 0;
    bgm.volume = 0;
  });

  stage = 0;
//currentBGM = null;
  checkStage();

  // UI 初期化
  gameClear.style.display = "none";
  restartButton.style.display = "none";
  //exitButton.style.display = "none"; // ← コメントアウト済みなら有効化してOK
  pauseButton.style.display = "inline";
  updateUI();

  // タイマー再設定
  clearInterval(obstacleGenerationInterval);
  clearInterval(scoreUpdateInterval);
  clearInterval(timeUpdateInterval);

  scoreUpdateInterval = setInterval(updateScore, 100);
  timeUpdateInterval = setInterval(updateTime, 30);

  // 🔁 ステップ⑤：コンボ監視ループ（1回だけ実行）
  if (!comboWatcherStarted) {
    comboWatcherStarted = true;
    setInterval(() => {
      if (!comboInProgress) return;

      const now = Date.now();
      if (comboReflectedCount <= 0 && now - comboLastUpdateTime > 300) {
        finishComboBonus();
      }
    }, 100);
  }
}

// 最初の入力で起動
window.addEventListener("mousedown", startGame, { once: true });
window.addEventListener("keydown",   startGame, { once: true });
restartButton.addEventListener("click", startGame);

// 再スタートボタン処理
restartButton.addEventListener("click", startGame);
// 再スタートボタン処理（スマホ対応）← 追加
restartButton.addEventListener("touchstart", (e) => {
  e.preventDefault(); // iOSでのフォーカス・選択など防止
  startGame();
});

// タイトル画面：スマホ対応
titleScreen.addEventListener("touchstart", () => {
  if (!gameStarted && !enteringName) startGame();  // ← enteringName を追加
});
/* =======================================================
   ▼ ゲーム終了スマホ対応
   ======================================================= */
function handleExit() {
  const closed = window.close(); // 閉じようと試みる（※多くのスマホで無効）
  alert("ゲームを終了します。ブラウザを閉じてください。");
}
/* =======================================================
   ▼ ポーズ機能処理
   ======================================================= */
function pauseGame() {
  pauseStart = Date.now(); 
  
  clearInterval(obstacleGenerationInterval);
  clearInterval(scoreUpdateInterval);
  clearInterval(timeUpdateInterval);
  if (currentBGM) currentBGM.pause();
}

// ▼ ポーズ／再開ボタン処理
const pauseButton = document.getElementById("pauseButton");
const resumeButton = document.getElementById("resumeButton");
const pauseOverlay = document.getElementById("pauseOverlay");

pauseButton.addEventListener("click", () => {
  if (gameOver || gamePaused) return;

  pauseGame(); // 既存関数を呼ぶ
  gamePaused = true;

  // UI切替
  pauseOverlay.style.display = "block";
  pauseButton.style.display = "none";
  resumeButton.style.display = "inline";
});

resumeButton.addEventListener("click", () => {
  if (gameOver || !gamePaused) return; 

  gamePaused = false;
  resumeGame();

  pauseOverlay.style.display = "none";
  pauseButton.style.display = "inline";
  resumeButton.style.display = "none";
});

// ▼ タブ非アクティブ時に自動ポーズ（スマホアプリ切り替え含む）
document.addEventListener("visibilitychange", () => {
  if (document.hidden && !gamePaused && !gameOver && gameStarted) {
    pauseGame();
    gamePaused = true;

    pauseOverlay.style.display = "block";
    pauseButton.style.display = "none";
    resumeButton.style.display = "inline";
  }
});

// ▼ 再開処理（resumeGame）を追加
function resumeGame() {
  const pauseEnd = Date.now(); 
  totalPausedTime += pauseEnd - pauseStart;

  // ✅ currentBGMがあれば再開（paused状態のもののみ）
  if (currentBGM) {
    if (currentBGM.paused) {
      currentBGM.play().then(() => {
        console.log("✅ BGM resumed:", currentBGM.src);
      }).catch(e => {
        console.warn("🔇 resumeGame: BGM play failed:", e);
      });
    } else {
      console.log("🔁 BGM was already playing:", currentBGM.src);
    }
  } else {
    console.warn("❌ resumeGame: currentBGM is null");
  }

  scoreUpdateInterval = setInterval(updateScore, 100);
  timeUpdateInterval = setInterval(updateTime, 30);
  resetObstacleSpawn(); // ← 再開時の障害物生成再開
}

/* =======================================================
   ▼ 障害物作成リセット処理
   ======================================================= */
function resetObstacleSpawn() {
  if (obstacleSpawnInterval !== null) {
    clearInterval(obstacleSpawnInterval);
    console.log("既存のspawnInterval停止");
  }

  // スコアに応じた出現間隔を定義
  let baseInterval = 800;
  if (score >= 200000) baseInterval = 400;
  else if (score >= 150000) baseInterval = 500;
  else if (score >= 100000) baseInterval = 600;
  else if (score >= 50000) baseInterval = 700;

  console.log(`[resetObstacleSpawn] baseInterval = ${baseInterval}`);

  obstacleSpawnInterval = setInterval(() => {
    if (!gameOver) createObstacle();
  }, baseInterval);
}

/* =======================================================
   ▼ 障害物作成処理
   ======================================================= */
function createObstacle() {
  if (gameOver || isPaused) return;
  const item = document.createElement("div");
  item.classList.add("obstacle");

  let sizeOption;
  let colorClass = "";
  let fallSpeed;

  // speedScaleの計算
  let speedScale = 1.0;
  if (score >= 150000) {
    const additionalScale = Math.min(Math.floor(score / 150000) * 1.2, 7.0);
    speedScale += additionalScale;
  }
  speedScale = Math.min(speedScale, 8.0);

  // ステージ別内容
  if (stage === 1) {
    sizeOption = Math.random() < 0.6 ? "small" : "big";
    colorClass = "red";
    fallSpeed = sizeOption === "small" ? 4 * speedScale : 3 * speedScale;
  } else if (stage === 2) {
    sizeOption = Math.random() < 0.7 ? "small" : "big";
    colorClass = "blue";
    fallSpeed = sizeOption === "small" ? 4 * speedScale : 5 * speedScale;
  } else if (stage === 3) {
    sizeOption = Math.random() < 0.8 ? "big" : "huge";
    colorClass = "green";
    fallSpeed = sizeOption === "big" ? 5 * speedScale : 2 * speedScale;
  } else if (stage === 4 || stage === 5) {
    const randomChoice = Math.random();
    if (randomChoice < 0.3) {
      sizeOption = "huge";
      colorClass = "red";
      fallSpeed = 3 * speedScale;
    } else if (randomChoice < 0.4) {
      sizeOption = "huge";
      colorClass = "blue";
      fallSpeed = 2 * speedScale;
    } else {
      sizeOption = "small";
      colorClass = "green";
      fallSpeed = 6 * speedScale;
    }
    item.classList.add("stage4");
  }

  // 表示設定
  const sizeStr = sizeOption;
  const colorInitial = colorClass[0].toUpperCase();
  item.style.backgroundImage = `url(enm_${sizeStr}_${colorInitial}.gif)`;
  item.style.backgroundSize = "cover";
  item.style.backgroundRepeat = "no-repeat";
  item.style.backgroundPosition = "center";
  item.style.pointerEvents = "none";

  // サイズとヒットボックス
  const sizeData = {
    small: 60,
    big: 92,
    huge: 172
  };
  const dimension = sizeData[sizeOption];
  item.style.width = dimension + "px";
  item.style.height = dimension + "px";
  item.dataset.hitboxW = dimension;
  item.dataset.hitboxH = dimension;

  item.style.backgroundColor = "transparent";
  item.dataset.hp = sizeOption === "small" ? 1 : sizeOption === "big" ? 2 : 3;
  item.dataset.type = "damage";
  item.dataset.stage = stage;
  item.dataset.size = sizeOption;
  item.dataset.color = colorClass;
  item.classList.add("obstacle");

  // 位置設定
  item.style.left = Math.floor(Math.random() * 9) * 40 + "px";
  item.style.top = "0px";
  item.style.position = "absolute";

  game.appendChild(item);
  allObstacles.push(item);

  let y = 0;
  const fall = setInterval(() => {
    if (gameOver || !item.parentElement) return clearInterval(fall);
    if (isPaused) return;
    y += fallSpeed;
    item.style.top = y + "px";

    const playerRect = hitbox.getBoundingClientRect();
    const itemRect = getAdjustedRect(item);

    if (checkCollision(playerRect, itemRect)) {
      if (!invincible && !superInvincible) {
        const dmg = parseInt(item.dataset.hp);
        lives -= dmg;
        if (lives <= 0) endGame();
        setInvincible();
      }
      item.remove();
      updateUI();
      clearInterval(fall);
      return;
    }

    if (y > 600) {
      item.remove();
      clearInterval(fall);
    }
  }, 30);

  // 🔄 落下用IDを保存（反射時に clear するため）
  item.fallInterval = fall;
}

/** ★ 指定ミリ秒で障害物生成タイマーを再セット */
function setObstacleTimer(interval) {
  clearInterval(obstacleTimerId);
  obstacleTimerId = setInterval(() => {
    if (!gameOver) createObstacle();
  }, interval); // ← interval は baseInterval を受け取るはず
}

//初期障害物発生間隔
/* ==== スコアに応じて生成間隔を更新 ==== */
function startObstacleGeneration(){
  // 初回起動
  setObstacleTimer(800);
}

/** ★ スコア更新ごとに呼ぶ（updateScore 内の最後に１行追加すればＯＫ） */
function updateObstacleIntervalByScore(score) {
  const newInterval = Math.max(200, 800 - Math.floor(score / 200000) * 200); // ← これが必要！
  const previousInterval = baseInterval;

  if (newInterval !== baseInterval) {
    baseInterval = newInterval;
    console.log(`[スコア更新] score=${score}, baseInterval変更: ${previousInterval} → ${baseInterval}`);
    resetObstacleSpawn();
  }
}

/* =======================================================
   ▼ アイテム生成と落下処理本体
   ======================================================= */
function spawnFallingItem(type) {
  const config = {
    heart: {
      emoji: "💗",
      speed: 5,
      condition: () => lives < maxLives && Math.random() < 0.10,
      onCollect: () => {
        lives = Math.min(lives + 1, maxLives);
        updateUI();
      }
    },
    goldHeart: {
      emoji: "💛",
      speed: 8,
      condition: () => lives <= 1 && Math.random() < 0.05,
      onCollect: () => {
        lives = maxLives;
        updateUI();
      }
    },
    lemon: {
      emoji: "🍋",
      speed: 5,
      condition: () => level < maxLevel && lives === maxLives && Math.random() < 0.05,
      onCollect: (x, y) => {
        const scoreAdd = 10000, expAdd = 300;
        createExplosion(x, y, scoreAdd, false, true, expAdd);
        score += scoreAdd;
        addExp(expAdd);
        updateUI();
      }
    },
    grape: {
      emoji: "🍇",
      speed: 5,
      condition: () => level >= maxLevel && Math.random() < 0.05,
      onCollect: (x, y) => {
        createExplosion(x, y, 15000, false, true);
        score += 15000;
        updateUI();
        setSuperInvincible(15000);
      }
    }
  };

  const itemData = config[type];
  if (!itemData || !itemData.condition() || gameOver || isPaused) return;

  const el = document.createElement("div");
  el.classList.add("heal"); // 共通クラス名（削除時に一括指定可能）
  el.textContent = itemData.emoji;
  el.style.left = Math.floor(Math.random() * 9) * 40 + "px";
  el.style.top = "0px";
  game.appendChild(el);

  let y = 0;

  const fall = setInterval(() => {
    if (gameOver || !el.parentElement) return clearFall();
    if (isPaused) return;

    y += itemData.speed;
    el.style.top = y + "px";

    const itemRect = el.getBoundingClientRect();
    const playerRect = hitbox.getBoundingClientRect();
    const gameRect = game.getBoundingClientRect();
    const centerX = itemRect.left + itemRect.width / 2 - gameRect.left;
    const centerY = itemRect.top + itemRect.height / 2 - gameRect.top;

    // プレイヤーと衝突
    if (checkCollision(itemRect, playerRect)) {
      el.remove();
      clearFall();
      if (seItem) {
        seItem.currentTime = 0;
        seItem.play().catch(e => console.warn("SE error:", e));
      }
      itemData.onCollect?.(centerX, centerY);
      return;
    }

    // 反射障害物との衝突
    for (let obs of allObstacles) {
      if (obs.dataset.type === "reflected") {
        const obsRect = obs.getBoundingClientRect();
        if (checkCollision(itemRect, obsRect)) {
          el.remove();
          clearFall();
          createExplosion(centerX, centerY);
          return;
        }
      }
    }

    // 画面外に出たら削除
    if (y > 600) {
      el.remove();
      clearFall();
    }
  }, 30);

  itemFallTimers.push(fall);

  // 安全にタイマー解除＋リストから削除
  function clearFall() {
    clearInterval(fall);
    itemFallTimers = itemFallTimers.filter(id => id !== fall);
  }
}
/* =======================================================
   ▼ ハート/レモン/グレープ生成の元コード置き換え
   ======================================================= */
function maybeSpawnHeart() {
  spawnFallingItem("goldHeart");
  spawnFallingItem("heart");
}
function maybeSpawnLemon() {
  spawnFallingItem("lemon");
}
function maybeSpawnGrape() {
  spawnFallingItem("grape");
}
/* =======================================================
   ▼ アイテム取得SE
   ======================================================= */
function loadAudio(audioEl) {
  return new Promise((resolve, reject) => {
    audioEl.oncanplaythrough = resolve;
    audioEl.onerror = reject;
    audioEl.load();
  });
}

/* =======================================================
   ▼ ステージ進行
   ======================================================= */
function updateStage() {
  const prev = stage;

  if (score >= 600000) {
    stage = 5; // ✅ 新ステージ5
  } else if (score >= 150000) {
    stage = 4;
  } else if (score >= 100000) {
    stage = 3;
  } else if (score >=  50000) {
    stage = 2;
  } else {
    stage = 1;
  }

  if (stage !== prev) {
    crossfadeBackground(stage);          // 背景のクロスフェード
    setStageBackgroundSpeed(stage);      // 背景スクロール速度変更
  }
}

/* =======================================================
   ▼ プレイヤー行動処理
   ======================================================= */
// 共通ヘルパー
function isLeftKey(key) {
  return key === "ArrowLeft" || key === "a" || key === "A";
}
function isRightKey(key) {
  return key === "ArrowRight" || key === "d" || key === "D";
}

// 回避移動
function dodge(dir) {
  if (isDodging) return;
  isDodging = true;
  speedBoost = true;
  if (seDodge) { seDodge.currentTime = 0; seDodge.play(); }
  setInvincible(300);
  player.classList.add("dodging");

  const flare = document.createElement("div");
  flare.className = "dodge-flare";
  player.appendChild(flare);

  const startX = playerX;
  spawnAfterImage(startX);

  for (let i = 0; i < 2; i++) {
    const delta = dir === "ArrowLeft" ? -STEP_PX : STEP_PX;
    const newX = Math.max(0, Math.min(360, playerX + delta));
    if (newX !== playerX) {
      playerX = newX;
      player.style.left = playerX + "px";
      hitbox.style.left = (playerX + 4) + "px";
    }
    if (i === 0) spawnAfterImage(playerX);
  }

  setTimeout(() => {
    speedBoost = false;
    isDodging = false;
    player.classList.remove("dodging");
    flare.remove();
  }, 300);
}

// 残像
function spawnAfterImage(xPos){
  const img = document.createElement("div");
  img.className = "afterimage";
  img.style.left = xPos + "px";
  img.style.bottom = "10px";
  img.style.backgroundImage = 'url("chr_moth.gif")';
  img.style.backgroundSize = 'cover';
  game.appendChild(img);
  setTimeout(() => img.remove(), 100);
}

// 通常移動
function stepMove(dir){
  if (gameOver || isPaused) return;
  const delta = speedBoost ? playerSpeed * 2 : playerSpeed;
  const prevX = playerX;

  if (dir === "ArrowLeft")  playerX = Math.max(0, playerX - delta);
  if (dir === "ArrowRight") playerX = Math.min(360, playerX + delta);

  if (playerX !== prevX) {
    player.style.left = playerX + "px";
    hitbox.style.left = (playerX + 4) + "px";
  }
}

// PCキーボード操作
document.addEventListener("keydown", e => {
  if (gameOver || isPaused) return;

  const key = e.key;
  if (key === "f" || key === "F" || key === "Enter") {
    activateParry();
    return;
  }

  const isLeft  = isLeftKey(key);
  const isRight = isRightKey(key);
  if (!isLeft && !isRight) return;

  const dirKey = isLeft ? "ArrowLeft" : "ArrowRight";

  // 長押しでは dodge 発動しない
  if (!e.repeat) {
    const now = performance.now();
    if (lastKey === dirKey && now - lastKeyTime <= DOUBLE_TAP_MS) {
      dodge(dirKey);
      lastKey = "";
    } else {
      lastKey = dirKey;
      lastKeyTime = now;
    }
  }

  keyPressed[dirKey] = true;
});

document.addEventListener("keyup", e => {
  const key = e.key;
  if (isLeftKey(key))  keyPressed["ArrowLeft"] = false;
  if (isRightKey(key)) keyPressed["ArrowRight"] = false;
});

// 通常移動ループ
function continuousMoveLoop() {
  if (!isPaused && !gameOver) {
    if (keyPressed["ArrowLeft"])  stepMove("ArrowLeft");
    if (keyPressed["ArrowRight"]) stepMove("ArrowRight");
  }
  requestAnimationFrame(continuousMoveLoop);
}
continuousMoveLoop();

// クリック／タップでパリィ
game.addEventListener("mousedown", () => {
  if (!gameOver) activateParry();
});
game.addEventListener("touchstart", e => {
  e.preventDefault();
  if (!gameOver) activateParry();
});

// タッチ長押しによる移動ループ（スマホ）
function startTouchHold(dirKey) {
  isTouchHolding = true;
  stopTouchHold();  // 前のループをクリア
  keyPressed[dirKey] = true;
  touchHoldInterval = setInterval(() => {
    stepMove(dirKey);
  }, 30);
}

function stopTouchHold() {
  clearInterval(touchHoldInterval);
  touchHoldInterval = null;
  isTouchHolding = false;
  keyPressed["ArrowLeft"] = false;
  keyPressed["ArrowRight"] = false;
}

// 🔁 ダブルタップ＆通常移動の兼用処理（スマホ用）
function handleTap(dirKey) {
  const now = performance.now();
  if (isTouchHolding) return; // 押しっぱ中はダブルタップ無視

  if (lastKey === dirKey && now - lastKeyTime <= DOUBLE_TAP_MS) {
    dodge(dirKey); // 2連打で回避移動
    lastKey = "";
  } else {
    lastKey = dirKey;
    lastKeyTime = now;
    stepMove(dirKey); // 通常移動1ステップ
  }
}

// 左ボタン（タッチ）
btnLeft.addEventListener("touchstart", e => {
  e.preventDefault();
  startTouchHold("ArrowLeft");
}, { passive: false });

btnLeft.addEventListener("touchend", e => {
  e.preventDefault();
  stopTouchHold();
  handleTap("ArrowLeft");
}, { passive: false });

btnLeft.addEventListener("touchcancel", stopTouchHold);

// 右ボタン（タッチ）
btnRight.addEventListener("touchstart", e => {
  e.preventDefault();
  startTouchHold("ArrowRight");
}, { passive: false });

btnRight.addEventListener("touchend", e => {
  e.preventDefault();
  stopTouchHold();
  handleTap("ArrowRight");
}, { passive: false });

btnRight.addEventListener("touchcancel", stopTouchHold);

// パリィボタン（タッチ）
btnParry.addEventListener("touchstart", e => {
  e.preventDefault();
  activateParry();
}, { passive: false });

// パリィ：ゲーム画面タップでも発動（スマホ）
game.addEventListener("touchstart", e => {
  e.preventDefault();
  if (!gameOver) activateParry();
}, { passive: false });

// ポーズ処理
pauseButton.addEventListener("click", () => {
  isPaused = true;
  pauseOverlay.style.display = "flex";
  pauseButton.style.display = "none";
  resumeButton.style.display = "inline";
});
resumeButton.addEventListener("click", () => {
  isPaused = false;
  pauseOverlay.style.display = "none";
  pauseButton.style.display = "inline";
  resumeButton.style.display = "none";
});


// ポーズ制御
pauseButton.addEventListener("click", () => {
  isPaused = true;
  pauseOverlay.style.display = "flex";
  pauseButton.style.display = "none";
  resumeButton.style.display = "inline";
});
resumeButton.addEventListener("click", () => {
  isPaused = false;
  pauseOverlay.style.display = "none";
  pauseButton.style.display = "inline";
  resumeButton.style.display = "none";
});

/* ★★★★★★★★★★  入力ハンドラここまで  ★★★★★★★★★★ */

  // タイムの更新（ミリ秒単位）
  function updateTime() {
    if (isPaused) return;
    if (gameOver) return; // ゲームオーバー時にはタイム更新しない
    gameTime = (Date.now() - startTime - totalPausedTime); // ✅ ポーズ時間を除外
    timeEl.innerHTML = `タイム: ${(gameTime / 1000).toFixed(3)}秒`;  // 小数点以下3桁で表示
    
      // 👇 ここにもログを追加
//console.log("🕒 タイム進行中 gameTime =", gameTime);
  }

// スコアの更新 ─ 100ms ごとに +10 加算し整数で表示 & ステージ/BGM 判定も実施
function updateScore() {
  if (isPaused) return;
  if (gameOver) return;                       // ゲームオーバー中は更新しない

  const elapsed = Date.now() - startTime;     // 経過ミリ秒
  const tick    = Math.floor(elapsed / 100);  // 100ms 単位のカウンタ

  // 100ms 進んだらスコア加算
  if (tick > lastScoreUpdateTime) {
    lastScoreUpdateTime = tick;
    score += 10;

    /* ▼ ここでステージ切り替え & BGM クロスフェードを判定 */
    if (typeof checkStage === "function") {
      checkStage();   // ← 事前に追加した checkStage() を呼ぶ
    }

    // UI 反映（小数点以下なし）
    scoreEl.textContent = "スコア: " + Math.floor(score);
    updateObstacleIntervalByScore(score);
  }
}

/* =======================================================
   ▼ パリィ/ジャストパリィ
   ======================================================= */
function activateParry() {
  if (gameOver || isPaused) return;
  if (parryActive || Date.now() - lastParryTime < PARRY_COOLDOWN) return;
  lastParryTime = Date.now();

  seParry.play();
  setInvincible(350);

  parryActive = true;
  justParry = false;

  // 通常パリィエフェクト（半径55px, サイズ110×110）
  const effect = document.createElement("img");
  effect.src = "eff_parry.gif";
  effect.style.position = "absolute";
  effect.style.left = (player.offsetLeft + player.offsetWidth / 2 - 55) + "px";
  effect.style.top = (player.offsetTop + player.offsetHeight / 2 - 55) + "px";
  effect.style.width = "110px";
  effect.style.height = "110px";
  effect.style.pointerEvents = "none";
  effect.style.zIndex = "3";
  game.appendChild(effect);

  // ジャストじゃなかったら後で消す
  setTimeout(() => {
    if (!justParry) effect.remove();
  }, 350);

  setTimeout(() => {
    const pRect = player.getBoundingClientRect();
    const pcx = (pRect.left + pRect.right) / 2;
    const pcy = (pRect.top + pRect.bottom) / 2;

    for (let i = 0; i < allObstacles.length; i++) {
      const obs = allObstacles[i];
      if (!obs || !obs.parentElement || obs.dataset.type !== "damage") continue;

      const oRect = getAdjustedRect(obs);
      const dx = Math.max(oRect.left - pcx, 0, pcx - oRect.right);
      const dy = Math.max(oRect.top - pcy, 0, pcy - oRect.bottom);
      const dist = Math.hypot(dx, dy);

        if (dist <= justParryRadius) {
          justParry = true;
          effect.remove(); // 通常パリィエフェクト削除
          showJustParry();
          reflectObstacle(obs, true); // 🌈ジャスト反射
          setInvincible(350);         // 🌈無敵延長

        // ジャストエフェクト表示
        const jSize = 60;
        const j = document.createElement("img");
        j.src = "eff_just_parry.gif";
        j.style.position = "absolute";
        j.style.left = (player.offsetLeft + player.offsetWidth / 2 - jSize / 2) + "px";
        j.style.top = (player.offsetTop + player.offsetHeight / 2 - jSize / 2) + "px";
        j.style.width = jSize + "px";
        j.style.height = jSize + "px";
        j.style.pointerEvents = "none";
        j.style.zIndex = "3";
        game.appendChild(j);
        setTimeout(() => j.remove(), 580);
        break;
      } else if (dist <= normalParryRadius) {
        reflectObstacle(obs, false); // 通常反射
        break;
      }
    }
  }, 70);

  setTimeout(() => {
    parryActive = false;
    justParry = false;
  }, PARRY_COOLDOWN);
}

/* =======================================================
   ▼ ジャストパリィエフェクト表示
   ======================================================= */
function showJustParry() {
  const j = document.createElement("img");
  j.src = "eff_just_parry.gif";
  j.style.position = "absolute";
  j.style.left = (player.offsetLeft + player.offsetWidth / 2 - 30) + "px";
  j.style.top = (player.offsetTop + player.offsetHeight / 2 - 30) + "px";
  j.style.width = "60px";
  j.style.height = "60px";
  j.style.pointerEvents = "none";
  j.style.zIndex = "3";
  game.appendChild(j);

  if (seJustParry) {
    seJustParry.currentTime = 0;
    seJustParry.play().catch(e => console.warn("JustParry音再生失敗:", e));
  }

  setTimeout(() => j.remove(), 580);
}

/* =======================================================
   ▼ 被ダメージ時の半透明処理
   ======================================================= */
  function setInvincible(duration = 1000) {
    invincible = true;
    player.style.opacity = "0.5";
    setTimeout(() => {
      invincible = false;
      player.style.opacity = "1";
    }, duration);
  }

/* =======================================================
   ▼ 無敵処理
   ======================================================= */
function setSuperInvincible(duration = 15000) {
  superInvincible = true;

  orb1 = document.createElement("div");
  orb2 = document.createElement("div");
  orb1.className = "invincible-orb orb1";
  orb2.className = "invincible-orb orb2";
  player.appendChild(orb1);
  player.appendChild(orb2);

  setTimeout(() => {
    superInvincible = false;
    orb1?.remove();
    orb2?.remove();
  }, duration);
}

/* =======================================================
   ▼ 爆発発生処理
   ======================================================= */
function createExplosion(x, y, scoreValue = 0, isJust = false, noExplosion = false, expValue = 0) {
  // ---------- 爆発エフェクト ----------
  if (!noExplosion) {
    const explosion = document.createElement("img");
    explosion.src = "eff_bomb_L.gif";
    explosion.style.position = "absolute";
    explosion.style.left = x + "px";  // ← 余計な +20 削除
    explosion.style.top  = y + "px";
    explosion.style.width = "100px";
    explosion.style.height = "100px";
    explosion.style.transform = "translate(-50%, -50%)";
    explosion.style.pointerEvents = "none";
    explosion.style.zIndex = "10";
    game.appendChild(explosion);
      // 🔊 爆発音を再生
  if (seBombL) {
    seBombL.currentTime = 0;
    seBombL.play();
  }

    setTimeout(() => explosion.remove(), 400);
  }

  // ---------- スコア + 経験値表示 ----------
  if (scoreValue > 0) {
    const scoreText = document.createElement("div");
    scoreText.textContent = `+${scoreValue}${expValue > 0 ? `\nEXP+${expValue}` : ""}`;
    scoreText.style.position = "absolute";
    scoreText.style.left = x + "px";       // ← 余計な +20 削除
    scoreText.style.top  = (y - 10) + "px";
    scoreText.style.fontSize = "12px";     // ← 一段階小さく
    scoreText.style.fontWeight = "bold";
    scoreText.style.whiteSpace = "pre";    // 改行あり
    scoreText.style.color = isJust ? "yellow" : "white";
    scoreText.style.zIndex = "15";
    scoreText.style.pointerEvents = "none";
    scoreText.style.transform = "translate(-50%, 0px)";
    game.appendChild(scoreText);

    // 浮き上がって消えるアニメーション
    let offset = 0;
    const floatUp = setInterval(() => {
      offset += 1;
      scoreText.style.transform = `translate(-50%, -${offset}px)`;
      if (offset > 50) {  // ← 表示時間 約2秒（40ms × 50）
        clearInterval(floatUp);
        scoreText.remove();
      }
    }, 40);
  }
}
/* =======================================================
   ▼ 爆発発生処理軽量化
   ======================================================= */
function safeCreateExplosion(x, y, score, isJust, isBomb, exp) {
  const now = Date.now();
  if (now - lastExplosionTime < 50) return;  // 50ms以内ならスキップ
  lastExplosionTime = now;

  createExplosion(x, y, score, isJust, isBomb, exp);
}

/* =======================================================
   ▼ コンボ数表示の更新（画面右上に ○Hits!）
   ======================================================= */
function updateComboDisplay(currentComboCount) {
  if (currentComboCount < 2) return; // ✅ 1Hits! は表示しない

  const cappedCount = Math.min(currentComboCount, 50); // ✅ 上限50Hits!

  let comboText = document.getElementById("comboText");
  if (!comboText) {
    comboText = document.createElement("div");
    comboText.id = "comboText";
    game.appendChild(comboText);
  }

  // ✅ 毎回スタイルを上書き（CSS影響を受けない）
  comboText.style.position = "absolute";
  comboText.style.top = "450px";           // ← 表示位置を確実に反映
  comboText.style.right = "10px";
  comboText.style.fontSize = "24px";
  comboText.style.fontWeight = "bold";
  comboText.style.color = "cyan";
  comboText.style.zIndex = "100";
  comboText.style.pointerEvents = "none";
  comboText.style.textShadow = "1px 1px 2px black";

  comboText.style.display = "block";
  comboText.textContent = `${cappedCount} Hits!`; // ← 表示にも上限反映

  // ✅ コンボ終了タイマーの制御（600ms後にフィニッシュ処理）
  if (comboEndTimeout) clearTimeout(comboEndTimeout);
  comboEndTimeout = setTimeout(() => {
    finishComboBonus();
    comboEndTimeout = null;
  }, 600);
}

/* =======================================================
   ▼ コンボ数表示
   ======================================================= */
function createComboText(x, y, hits) {
  if (hits < 2) return; // ✅ 1Hits! は表示しない

  const comboText = document.createElement("div");
  comboText.textContent = `${hits} Hits!`;
  comboText.style.position = "absolute";
  comboText.style.left = `${x}px`;
  comboText.style.top = `${y}px`;
  comboText.style.fontSize = "22px";
  comboText.style.fontWeight = "bold";
  comboText.style.color = "cyan";
  comboText.style.textShadow = "1px 1px 2px black";
  comboText.style.pointerEvents = "none";
  comboText.style.zIndex = "100";
  comboText.style.opacity = "1";
  comboText.style.transform = "translateY(0)";
  comboText.style.transition = "transform 0.6s ease-out, opacity 0.6s ease-out";

  document.getElementById("game").appendChild(comboText);

  setTimeout(() => {
    comboText.style.transform = "translateY(-30px)";
    comboText.style.opacity = "0";
  }, 10);

  setTimeout(() => {
    comboText.remove();
  }, 800);
}

/* =======================================================
   ▼ フィニッシュコンボボーナス表記
   ======================================================= */
function finishComboBonus() {
  if (comboBonusGiven || currentComboCount < 2) return;

  comboBonusGiven = true;

  const cappedCount = Math.min(currentComboCount, 50); // ✅ 最大50Hits扱い
  const bonusScore = cappedCount * 1000;
  const bonusExp = cappedCount * 10;
  score += bonusScore;
  addExp(bonusExp);

  const bonusDiv = document.createElement("div");
  bonusDiv.innerText = `+${bonusScore}\nEXP+${bonusExp}`;
  bonusDiv.style.position = "absolute";
  bonusDiv.style.right = "5%";
  bonusDiv.style.top = "100%";
  bonusDiv.style.transform = "translateY(350px)";
  bonusDiv.style.fontSize = "20px";
  bonusDiv.style.fontWeight = "bold";
  bonusDiv.style.whiteSpace = "pre";
  bonusDiv.style.color = "aqua";
  bonusDiv.style.textShadow = "2px 2px 4px black";
  bonusDiv.style.pointerEvents = "none";
  bonusDiv.style.zIndex = "100";

  game.appendChild(bonusDiv);

  // 浮き上がり＆フェードアウトアニメーション
  let offset = 0;
  let opacity = 1;
  const floatUp = setInterval(() => {
    offset += 2;
    opacity -= 0.03;
    bonusDiv.style.top = `${100 - offset}px`; // ← 上にずらす
    bonusDiv.style.opacity = opacity;
    if (offset > 50 || opacity <= 0) {
      clearInterval(floatUp);
      bonusDiv.remove();
    }
  }, 30);

  // ✅ コンボ情報リセット
  currentComboCount = 0;
  comboBonusGiven = false;
  comboInProgress = false;

  // ✅ コンボUIを非表示
  const comboText = document.getElementById("comboText");
  if (comboText) comboText.style.display = "none";

  // ✅ タイマーを明示的に解除
  if (comboEndTimeout) {
    clearTimeout(comboEndTimeout);
    comboEndTimeout = null;
  }

  updateUI();
}

/* =======================================================
   ▼ UIの更新処理
   ======================================================= */
function updateUI() {
  // ハートの数表示（負のrepeat対策あり）
  livesEl.innerHTML =
    "❤️".repeat(Math.max(0, lives)) +
    "🖤".repeat(Math.max(0, maxLives - lives));

  // レベル表示
  levelEl.textContent = "Lv. " + level;

  // 経験値表示
  if (level < maxLevel) {
    expEl.textContent = `EXP: ${exp} / ${level * 200}`;
  } else {
    expEl.textContent = `EXP: MAX`;
  }

  // スコア表示
  scoreEl.textContent = "スコア: " + score;
}

/* =======================================================
   ▼ 経験値追加
   ======================================================= */
function addExp(amount) {
  if (level >= maxLevel) return;

  exp += amount;
  let threshold = level * 200;

  let levelUps = 0;

  while (exp >= threshold && level < maxLevel) {
    exp -= threshold;
    level++;
    maxLives++;
    levelUps++;
    playerSpeed *= 1.05;
    threshold = level * 200;

    // ✅ レベルアップごとにジャストパリィ判定距離 +2
    justParryRadius = Math.min(justParryRadius + 2, 52); // Lv1:40 → Lv7:52
  }

  // ライフ回復は最後に1回だけまとめて処理
  if (levelUps > 0) {
    lives = Math.min(lives + levelUps, maxLives);
  }

  updateUI();
}

/* =======================================================
   ▼ 障害物ダメージ表現
   ======================================================= */
  function applyHitFlash(obstacle) {
    obstacle.style.filter = "brightness(2)";
    setTimeout(() => {
      if (obstacle) obstacle.style.filter = "";
    }, 150);
  }
/* =======================================================
   ▼ コリジョン判定
   ======================================================= */
  function checkCollision(r1, r2) {
    return !(r1.top > r2.bottom || r1.bottom < r2.top || r1.left > r2.right || r1.right < r2.left);
  }

/* =======================================================
   ▼ 障害物コリジョンサイズ変更（高さ）
   ======================================================= */
function getAdjustedRect(elem) {
  const rect = elem.getBoundingClientRect();
  const newHeight = rect.height * 0.7;

  return {
    top: rect.bottom - newHeight,        // ← 下寄せに変更
    bottom: rect.bottom,
    left: rect.left,
    right: rect.right,
    width: rect.width,
    height: newHeight
  };
}
/* =======================================================
   ▼ 障害物同士のコリジョン判定
   ======================================================= */
function rectsOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
  return (
    ax < bx + bw &&
    ax + aw > bx &&
    ay < by + bh &&
    ay + ah > by
  );
}

/* =======================================================
   ▼ 反射処理（反射できる障害物に対して反射を行う）
   ======================================================= */
function reflectObstacle(obstacle, isRainbow) {
  // 🛑 元の落下処理を停止
  if (obstacle.fallInterval) {
    clearInterval(obstacle.fallInterval);
    obstacle.fallInterval = null;
  }

  let hp = parseInt(obstacle.dataset.hp);
  obstacle.dataset.type = "reflected";
  obstacle.dataset.hp = hp;

  let y = parseInt(obstacle.style.top);
  let vy = -obstacleSpeed * (isRainbow ? 1.5 : 1);

  if (isRainbow) {
    obstacle.classList.add("rainbow");
    comboReflectedCount++;
  }

  // 当たり判定拡大
  const originalW = parseFloat(obstacle.dataset.hitboxW);
  const originalH = parseFloat(obstacle.dataset.hitboxH);
  const expandedW = originalW * 1.2;
  const expandedH = originalH * 1.2;
  obstacle.dataset.hitboxW = expandedW;
  obstacle.dataset.hitboxH = expandedH;

  setTimeout(() => {
    if (obstacle && obstacle.parentElement) {
      obstacle.dataset.hitboxW = originalW;
      obstacle.dataset.hitboxH = originalH;
    }
  }, 500);

  let removed = false;

  setTimeout(() => {
    if (!removed && obstacle && obstacle.parentElement) {
      if (obstacle.classList.contains("rainbow")) {
        comboReflectedCount--;
        if (comboReflectedCount <= 0) {
          comboLastUpdateTime = Date.now();
          comboInProgress = true;
        }
      }
      obstacle.remove();
      removed = true;
    }
  }, 2000);

  const move = setInterval(() => {
    if (!obstacle.parentElement) return clearInterval(move);
    y += vy;
    obstacle.style.top = y + "px";

    if (!obstacle.frameCount) obstacle.frameCount = 0;
    obstacle.frameCount++;
    if (obstacle.frameCount % 2 !== 0) return;

    const selfW = parseFloat(obstacle.dataset.hitboxW || originalW);
    const selfH = parseFloat(obstacle.dataset.hitboxH || originalH);
    const selfX = parseInt(obstacle.style.left);
    const selfY = y;

    for (let other of allObstacles) {
      if (other === obstacle || !other.parentElement) continue;

      const otherX = parseInt(other.style.left);
      const otherY = parseInt(other.style.top);
      const otherW = parseFloat(other.dataset.hitboxW || other.offsetWidth);
      const otherH = parseFloat(other.dataset.hitboxH || other.offsetHeight);

      if (!rectsOverlap(selfX, selfY, selfW, selfH, otherX, otherY, otherW, otherH)) continue;

      const hp1 = parseInt(obstacle.dataset.hp);
      const hp2 = parseInt(other.dataset.hp);
      const stageType = parseInt(other.dataset.stage || 1);
      const size = other.dataset.size;
      const color = other.dataset.color;

      let scoreAdd = 0;
      let expAdd = 0;

      if (stageType === 1 || stageType === 2) {
        scoreAdd = hp2 === 2 ? 1000 : 500;
        expAdd = hp2 === 2 ? 10 : 5;
      } else if (stageType === 3) {
        scoreAdd = hp2 === 3 ? 1500 : 1000;
        expAdd = hp2 === 3 ? 15 : 10;
      } else if (stageType === 4) {
        if (hp2 === 3 && size === "huge" && color === "blue") {
          scoreAdd = 6000;
          expAdd = 60;
        } else if (hp2 === 3) {
          scoreAdd = 4000;
          expAdd = 40;
        } else if (hp2 === 1) {
          scoreAdd = 1500;
          expAdd = 15;
        }
      } else if (stageType >= 5) {
        if (hp2 === 3 && size === "huge" && color === "blue") {
          scoreAdd = 7000;
          expAdd = 70;
        } else if (hp2 === 3) {
          scoreAdd = 5000;
          expAdd = 50;
        } else if (hp2 === 2) {
          scoreAdd = 3000;
          expAdd = 30;
        } else if (hp2 === 1) {
          scoreAdd = 2000;
          expAdd = 20;
        }
      }

      if (isRainbow) {
        score += scoreAdd * 2;
        addExp(expAdd);
        safeCreateExplosion(otherX, otherY, scoreAdd * 2, true, false, expAdd);
        other.remove();

        if (!comboInProgress && currentComboCount === 0) {
          currentComboCount = 2;
          comboBonusGiven = false;
        } else {
          currentComboCount++;
        }

        updateComboDisplay(currentComboCount);
        comboLastUpdateTime = Date.now();
        comboInProgress = true;

      } else {
        if (hp1 === hp2) {
          score += scoreAdd;
          addExp(expAdd);
          safeCreateExplosion(otherX, otherY, scoreAdd, false, false, expAdd);
          obstacle.remove();
          other.remove();
          clearInterval(move);
          removed = true;
        } else if (hp1 > hp2) {
          score += scoreAdd;
          addExp(expAdd);
          safeCreateExplosion(otherX, otherY, scoreAdd, false, false, expAdd);
          obstacle.dataset.hp = hp1 - 1;
          other.remove();
        } else {
          other.dataset.hp = hp2 - 1;
          other.style.opacity = "0.4";
          setTimeout(() => {
            if (other) other.style.opacity = "1";
          }, 150);
          obstacle.remove();
          clearInterval(move);
          removed = true;
        }
      }

      updateUI();
    }

    if (y < 0 && !removed) {
      if (obstacle.classList.contains("rainbow")) {
        comboReflectedCount--;
        if (comboReflectedCount <= 0) {
          comboLastUpdateTime = Date.now();
          comboInProgress = true;
        }
      }
      obstacle.remove();
      removed = true;
      clearInterval(move);
    }
  }, 30);
}

/* =======================================================
   ▼ ゲームクリア時のRANK判定
   ======================================================= */
function getRating(score, time, isMillis = false) {
  const timeInSeconds = isMillis ? time / 1000 : time;
  const spt = score / timeInSeconds;

  if (spt >= 4000) return "V";
  if (spt >= 3600) return "SS";
  if (spt >= 3200) return "S";
  if (spt >= 2800) return "A";
  if (spt >= 2400) return "B";
  if (spt >= 2000) return "C";
  if (spt >= 1600) return "D";
  return "E";
}
/* =======================================================
   ▼ ゲームクリア処理
   ======================================================= */
function endGame() {
  gameOver = true;

  // BGM停止
  bgm.Stage1.pause();
  bgm.Stage2.pause();
  bgm.Stage3.pause();
  bgm.Final.pause();
  if (bgm.Final2) bgm.Final2.pause(); // ✅ 追加

  // 既に追加されたGame Overテキストがあれば削除
  const existingOver = document.getElementById("gameOverText");
  if (existingOver) existingOver.remove();

  clearInterval(obstacleTimerId);

  // ▼▼▼ アイテム落下タイマーをすべて停止 ▼▼▼
  if (typeof itemFallTimers !== "undefined") {
    itemFallTimers.forEach(id => clearInterval(id));
    itemFallTimers = [];
  }

  // ▼▼▼ アイテムをすべて削除（.heal クラスを共通指定） ▼▼▼
  document.querySelectorAll(".heal").forEach(item => item.remove());

  // ゲームオーバー処理
  if (score < 150000) {
    const gameOverText = document.createElement("h2");
    gameOverText.id = "gameOverText";
    gameOverText.textContent = "Game Over!";
    gameOverText.style.color = "yellow";
    gameOverText.style.marginTop = "200px";
    game.appendChild(gameOverText);

    gameClear.style.display = "none";
    restartButton.style.display = "block";
    restartButton.style.pointerEvents = "auto";

    pauseButton.style.display = "none";
  } else {
    // ▼▼▼ 障害物削除処理 ▼▼▼
    allObstacles.forEach(obj => obj.remove());
    allObstacles.length = 0;

    // ゲームクリア処理
    const clearTime = (gameTime / 1000).toFixed(3);
    const rating = getRating(score, gameTime, true); // ミリ秒なので true を指定

    console.log("スコア:", score);
    console.log("ゲームタイム（秒）:", clearTime);
    console.log("スコア ÷ タイム:", score / gameTime);
    console.log("RANK:", rating);

    timeRatingEl.textContent = `RANK: ${rating}`;

    // ✅ ▼▼▼ Vランク演出 ▼▼▼
    if (rating.trim().toUpperCase() === "V") {
      timeRatingEl.classList.add("void-rank");

      const existingSubtext = timeRatingEl.parentElement.querySelector(".void-subtext");
      if (existingSubtext) existingSubtext.remove();

      const subtext = document.createElement("div");
      subtext.textContent = "V - VOID RANK";
      subtext.className = "void-subtext";
      timeRatingEl.parentElement.appendChild(subtext);

      triggerVoidFeathers();
    }
    // ✅ ▲▲▲ Vランクここまで ▲▲▲

    showMusicTitle("♪Twilight Flutter");

    gameClear.style.display = "flex";
    restartButton.style.display = "block";
    document.getElementById("thankYouText").style.display = "block";

    // ✅ 表示用ランキングを更新
    displayHighScores();

    // ✅ UI表示が終わってからハイスコアチェックを呼ぶ
    setTimeout(() => {
      checkAndRegisterHighScore(score, rating);
    }, 500);
  }

  // ✅ クリアBGM再生
  bgm.Result.currentTime = 0;
  bgm.Result.volume = 0.8;
  bgm.Result.play();

  pauseButton.style.display = "none";

  updateUI();
}


setInterval(() => {
  if (gameStarted && !gameOver) {
    maybeSpawnHeart(); // ハート生成
    maybeSpawnLemon(); // レモン生成
    maybeSpawnGrape(); // ← ここに追加！
    updateStage();
  }
}, 2500);

/* =======================================================
   ▼Vランクの特殊羽根演出（新規追加関数）
   ======================================================= */
function triggerVoidFeathers() {
  const container = document.getElementById("voidFeathers");
  const game = document.getElementById("game");
  if (!container || !game) return;

  container.innerHTML = "";
  container.style.display = "block";

  const featherCount = 20;
  const maxSpread = 240;
  const gravityY = 30;

  const gameRect = game.getBoundingClientRect();
  const centerX = gameRect.width / 2;
  const centerY = gameRect.height / 3;

  for (let i = 0; i < featherCount; i++) {
    const feather = document.createElement("div");
    feather.className = "feather";

    const angle = Math.PI + Math.random() * Math.PI;
    const radius = Math.random() * maxSpread;
    const dx = Math.cos(angle) * radius;
    const dy = Math.sin(angle) * radius + 180;

    const flyTimeSec = (5.0 + Math.random()).toFixed(2);
    const rotateSpeedSec = (8.0 + Math.random() * 2).toFixed(2);

    const startAngle = Math.floor(Math.random() * 360);
    const midAngle = startAngle + (Math.random() * 60 - 30);
    const endAngle = midAngle + (Math.random() * 60 - 30);

    feather.style.setProperty("--dx", dx);
    feather.style.setProperty("--dy", dy);
    feather.style.setProperty("--flyTime", `${flyTimeSec}s`);
    feather.style.setProperty("--rotateSpeed", `${rotateSpeedSec}s`);
    feather.style.setProperty("--startAngle", `${startAngle}deg`);
    feather.style.setProperty("--midAngle", `${midAngle}deg`);
    feather.style.setProperty("--endAngle", `${endAngle}deg`);

    feather.style.left = `${centerX}px`;
    feather.style.top = `${centerY}px`;

    // ✅ 正しい場所に追加（これが重要！）
    game.appendChild(feather); 

    // アニメ後削除
    setTimeout(() => {
      feather.remove();
    }, parseFloat(flyTimeSec) * 1000 - 400);
  }
}

/* =======================================================
   ▼ ハイスコア名前入力
   ======================================================= */
function checkAndRegisterHighScore(score, rating) {
  console.log("✅ checkAndRegisterHighScore が呼ばれました");
  console.log("🔍 score:", score, "rating:", rating);
  console.log("💬 enteringName:", enteringName, "newHighScore:", window.newHighScore);
  console.log("📌 gameStarted:", gameStarted, "gameOver:", gameOver);

  const coefficient = ratingCoefficients[rating] || 1.0;
  const newPower = score * coefficient;
  console.log("🧮 RANK係数:", coefficient, "→ パワー:", newPower);

  // ⚠️ 前回の newHighScore が残っていたらクリア（念のため）
  if (gameStarted && gameOver && !enteringName && window.newHighScore) {
    console.log("🧹 前回の newHighScore をリセット");
    window.newHighScore = null;
  }

  if (enteringName || window.newHighScore) {
    console.log("⚠️ すでに名前登録中または完了済み。スキップします。");
    return;
  }
  if (gameStarted === false || gameOver === false) {
    console.log("⚠️ ゲームがまだ終了していません。スキップします。");
    return;
  }

  if (score < 150000 || !ratingCoefficients[rating]) {
    console.log("❌ スコアが基準未満か、RANK係数が無効。");
    return;
  }

  // 現在のハイスコアをパワー順にソート
  highScores.sort((a, b) => {
    const aPower = a.score * (ratingCoefficients[a.rating] || 1.0);
    const bPower = b.score * (ratingCoefficients[b.rating] || 1.0);
    return bPower - aPower;
  });

  const lowestPower = highScores.length < 5 ? 0 :
    highScores[4].score * (ratingCoefficients[highScores[4].rating] || 1.0);

  console.log("🏆 最下位Power:", lowestPower, "vs 今回のPower:", newPower);

  if (newPower > lowestPower) {
    console.log("🎉 ハイスコア入り判定成功！名前入力を表示します");

    enteringName = true;
    namePos = 0;
    // ✅ 前回の名前を初期値に反映（localStorage）
    const lastName = localStorage.getItem("lastEnteredName") || "AAAA";
    nameChars = lastName.split("").slice(0, 4);
    while (nameChars.length < 4) nameChars.push("A");
  
    updateNameEntryDisplay();

    const entryScreen = document.getElementById("nameEntryScreen");
    if (entryScreen) {
      entryScreen.style.display = "flex";
      entryScreen.style.zIndex = "9999"; // 念のため
    } else {
      console.log("❗ nameEntryScreen が見つかりません！");
    }

    window.newHighScore = { score, rating };
  } else {
    console.log("⛔ ハイスコア入りせず。スキップします");
  }
}

function updateNameEntryDisplay() {
  const str = nameChars.map((c, i) => (i === namePos ? `[${c}]` : c)).join(" ");
  document.getElementById("nameEntry").textContent = str;

  // 「次へ」または「決定」の切り替え
  const confirmBtn = document.getElementById("confirmButton");
  if (confirmBtn) {
    confirmBtn.textContent = (namePos === nameChars.length - 1) ? "決定" : "次へ";
  }

  // 「前へ」ボタンの有効/無効制御
  const backBtn = document.getElementById("backButton");
  if (backBtn) {
    backBtn.disabled = (namePos === 0); // 最初の文字では無効化
    backBtn.style.opacity = (namePos === 0) ? 0.3 : 1;
  }
}

function nextChar() {
  if (!enteringName) return;
  const idx = availableChars.indexOf(nameChars[namePos]);
  const nextIdx = (idx + 1) % availableChars.length;
  nameChars[namePos] = availableChars[nextIdx];
  updateNameEntryDisplay();
}

function prevChar() {
  if (!enteringName) return;
  const idx = availableChars.indexOf(nameChars[namePos]);
  const prevIdx = (idx - 1 + availableChars.length) % availableChars.length;
  nameChars[namePos] = availableChars[prevIdx];
  updateNameEntryDisplay();
}

function goBackChar() {
  if (namePos > 0) {
    namePos--;
    updateNameEntryDisplay();
  }
}

function displayTopHighScore() {
  const top = highScores[0];
  if (!top) return;
  const coeff = ratingCoefficients[top.rating] || 1.0;
  const power = Math.floor(top.score * coeff);
  const display = `${top.name}　${top.score.toLocaleString()}　RANK：${top.rating}`;
  document.getElementById("topHighScore").textContent = display;
}

window.addEventListener("DOMContentLoaded", () => {
  document.getElementById("nameEntryScreen").style.display = "none";
  enteringName = false;
  window.newHighScore = null;

  // ✅ タイトル画面にトップハイスコアを表示
  displayTopHighScore();
});

function getRatingMultiplier(rating) {
  return ratingCoefficients[rating] || 1.0;
}
  // ✅ 名前決定
function confirmNameEntry() {
  if (!enteringName) return;

  // 次の文字へ移動
  namePos++;

  if (namePos < nameChars.length) {
    updateNameEntryDisplay();
    return; // まだ未確定の文字があるので確定しない
  }

  // 4文字すべて確定済み
  const name = nameChars.join("");
  highScores.push({
    name,
    score: window.newHighScore.score,
    rating: window.newHighScore.rating
  });

  // 再度ソート＆5件に絞る
  highScores.sort((a, b) => {
    const aPower = a.score * (ratingCoefficients[a.rating] || 1.0);
    const bPower = b.score * (ratingCoefficients[b.rating] || 1.0);
    return bPower - aPower;
  });
  highScores = highScores.slice(0, 5);
  saveHighScores(highScores);

  // UI処理
  document.getElementById("nameEntryScreen").style.display = "none";
  enteringName = false;

  // 🎯 入力直後に即反映！
  displayHighScores();
  
    // ✅ 入力した名前を保存
  localStorage.setItem("lastEnteredName", name);

  // 念のため newHighScore をリセット
  window.newHighScore = null;

  // ゲームクリア画面を表示（再表示）
  gameClear.style.display = "flex";
}

/* =======================================================
   ▼ ハイスコア表
   ======================================================= */
function displayHighScores() {
  const scoreListEl = document.getElementById("scoreList");
  if (!scoreListEl) return;

  const ranks = highScores.map((entry, index) => {
    return `${index + 1}. ${entry.name}：${entry.score}（${entry.rating}）`;
  });

  scoreListEl.innerHTML = `<p>🏆 High Scores</p>` + ranks.map(r => `<div>${r}</div>`).join("");
}

/* =======================================================
   ▼ スマホ自動拡大表示
   ======================================================= */
window.addEventListener("load", function () {
  setTimeout(function () {
    window.scrollTo(0, 1);
  }, 100);
});
/* =======================================================
   ▼ visibilitychange イベントを追加
   ======================================================= */
document.addEventListener("visibilitychange", () => {
  if (document.hidden) {
    if (gameStarted && !gameOver) {
      pauseGame(); // ↓で定義
      pausedDueToVisibility = true;
    }
  } else {
    if (pausedDueToVisibility) {
      showResumeOverlay(); // ↓で定義
      pausedDueToVisibility = false;
    }
  }
});
/* =======================================================
   ▼デバッグ用コリジョン表示
   ======================================================= */
/*function drawCollisionBox(rect, color = "rgba(255, 0, 0, 0.3)") {
  const box = document.createElement("div");
  box.style.position = "absolute";
  box.style.left = rect.left + "px";
  box.style.top = rect.top + "px";
  box.style.width = rect.width + "px";
  box.style.height = rect.height + "px";
  box.style.backgroundColor = color;
  box.style.zIndex = "9999"; // 一番上に表示
  box.style.pointerEvents = "none";
  document.body.appendChild(box);

  // 少し経ったら消えるように（デバッグ用途）
  setTimeout(() => box.remove(), 100);
}*/


</script>
</body>
</html>
