<!DOCTYPE html> 
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>MOTHVOID</title>
  <style>
    body {
      margin: 0;
      background: #000;
      color: white;
      font-family: monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;  /* â† ç¸¦æ–¹å‘ã„ã£ã±ã„ã«ä½¿ã† */
      overflow: hidden;
    }
    #titleScreen {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 10;
    }
    #titleLogo {
      width: 380px;
      margin-bottom: 20px;
    }
    #pressToStart {
      font-size: 20px;
      color: #FFD700;
      animation: blink 2s infinite;
      font-family: 'monospace';
    }
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }
    #time {
      display: none;
    }
    #game {
      position: relative;
      width: 100vw;
      height: 150vw;
      max-width: 400px;
      max-height: 600px;
      background: #111;
      border: 2px solid #fff;
      overflow: hidden;
    }
    #player {
      position: absolute;
      width: 48px;
      height: 48px;
      bottom: 10px;
      left: 180px;
      background-image: url("chr_moth.gif");
      background-size: cover;
      z-index: 2;
    }
    #hitbox {
      position: absolute;
      width: 38px;
      height: 38px;
      bottom: 12px;
      left: 182px;
      pointer-events: none;
      z-index: 2;
    }
    .obstacle {
      position: absolute;
      width: 50px;
      height: 50px;
      background: red;
      z-index: 2;
    }
    .obstacle.stage4 {
      background-color: #555;
    }
    .afterimage {
      position: absolute;
      width: 40px;
      height: 40px;
      pointer-events: none;
      z-index: 2;
      animation: fade .1s forwards;
    }
    .afterimage::after {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, rgba(0, 200, 255, 0.4) 0%, rgba(0, 200, 255, 0.0) 80%);
      border-radius: 50%;
      box-shadow: 0 0 15px rgba(0, 200, 255, 0.3);
      top: 0;
      left: 0;
      pointer-events: none;
    }
    @keyframes fade {
      to { opacity: 0; }
    }
    .dodge-flare {
      position: absolute;
      width: 40px;
      height: 40px;
      top: 0;
      left: 0;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(0, 200, 255, 0.4), rgba(0, 200, 255, 0));
      pointer-events: none;
      z-index: 1;
    }
    .heal {
      position: absolute;
      width: 40px;
      height: 40px;
      font-size: 28px;
      color: pink;
      text-align: center;
      line-height: 40px;
      pointer-events: none;
    }
    .explosion {
      position: absolute;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: radial-gradient(circle, orange, red, transparent);
      animation: explode 0.4s ease-out forwards;
      pointer-events: none;
    }
    .rainbow {
      animation: rainbow 0.5s infinite;
    }
    @keyframes explode {
     0% { opacity: 1; transform: scale(0.5); }
     100% { opacity: 0; transform: scale(2); }
    }
    @keyframes rainbow {
      0% { filter: hue-rotate(0deg); }
      100% { filter: hue-rotate(360deg); }
    }
    .damage-flash {
      animation: flashWhite 0.15s ease-in-out;
    }
    @keyframes flashWhite {
      0% { filter: brightness(1); }
      50% { filter: brightness(3); }
      100% { filter: brightness(1); }
    }
   /* ã‚¹ã‚³ã‚¢ãƒ»ãƒ¬ãƒ™ãƒ«ãƒ»çµŒé¨“å€¤ï¼ˆç™½æ å¤–ï¼‰ */
    #uiTop {
      width: 400px;
      margin-bottom: 10px;
      color: white;
      font-family: monospace;
    }
    #score {
      text-align: center;
      font-size: 20px;
      margin-bottom: 4px;
    }
    #levelExpRow {
      display: flex;
      justify-content: space-between;
      font-size: 16px;
      padding: 0 10px;
    }
   /* ãƒãƒ¼ãƒˆï¼ˆãƒ©ã‚¤ãƒ•è¡¨ç¤ºï¼‰ç™½æ å†…å·¦ä¸Šã«è¡¨ç¤º */
    #lives {
      position: absolute;
      top: 5px;
      left: 5px;
      font-size: 20px;
      z-index: 5;
    }
    #gameClear, #gameOver {
      position: absolute;
      left: 0;
      width: 100%;
      height: 100%;
      display: none;
      justify-content: center;
      align-items: center;
      text-align: center;
      color: yellow;
      background: rgba(0, 0, 0, 0.7);
      font-size: 24px;
      z-index: 10;
    }
    #thankYouText {
      font-size: 36px;
      margin-bottom: 10px;
    }
    #timeRating {
      font-size: 30px;
      margin-bottom: 10px;
    }
    #credits {
      font-size: 16px;
    }
    #restartButton {
      display: none;
      position: absolute;
      left: 50%;
      top: 75%;
      transform: translateX(-50%);
      padding: 10px 20px;
      font-size: 18px;
      background-color: #f39c12;
      color: white;
      border: none;
      border-radius: 5px;
      z-index: 20;
      cursor: pointer;
    }
    #touchControls {
      display: flex;
      justify-content: space-between;
      align-items: flex-end;  /* â† ä¸‹æƒãˆã«å¤‰æ›´ */
      width: 400px;
      margin-top: 20px;
      padding: 0 10px;
      height: 80px;  /* â† é«˜ã•ã‚’å›ºå®š */
      position: relative;
    }
    #moveInstruction,
    #parryInstruction {
      position: absolute;
      bottom: 55px; /* â† ãƒœã‚¿ãƒ³ã‚ˆã‚Šä¸Šã«å›ºå®šè¡¨ç¤º */
      font-size: 14px;
      color: #FFD700;
      font-family: monospace;
      text-align: center;
      width: 120px;
      white-space: nowrap;
    }
    #moveInstruction {
      left: 20px;
    }
    #parryInstruction {
      right: 60px;
    }
    .arrowGroup {
      display: flex;
      gap: 30px;
      margin-left: 30px; /* â† çŸ¢å°å…¨ä½“ã‚’å³ã«ãšã‚‰ã™ */
    }
    .parryGroup {
      display: flex;
      justify-content: flex-end;
    }

    .control-button {
      width: 50px;
      height: 50px;
    }
    #btnParry {
      margin-right: 70px; /* â† å³è©°ã‚èª¿æ•´ */
      margin-top: 1px;   /* â† ãƒ‘ãƒªã‚£ã ã‘ã•ã‚‰ã«å°‘ã—ä¸‹ã« */
    }

    #screenFade {
      position: absolute;
      top: 0; left: 0;
      width: 400px;
      height: 600px;
      background: #000;
      pointer-events: none;
      opacity: 0;
      transition: opacity .75s ease;
      z-index: 9;
    }
    #background {
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      background-image: url("èƒŒæ™¯ç”»åƒã®ãƒ‘ã‚¹");
      background-size: 100% auto;
      background-repeat: repeat-y;
      background-position-y: 0px;
      z-index: 0;
    }

    .obstacle-img {
      position: absolute;
      pointer-events: none;
      transform: translate(-50%, -50%);
    }
    .score-popup {
      position: absolute;
      font-size: 18px;
      font-weight: bold;
      font-family: monospace;
      pointer-events: none;
      animation: floatUp 0.5s ease-out forwards;
      z-index: 100;
    }

    @keyframes floatUp {
      0% {
        opacity: 1;
        transform: translateY(0px);
      }
      100% {
        opacity: 0;
        transform: translateY(-30px);
      }
    }
  </style>
</head>

<body>
  <!-- UIã‚¨ãƒªã‚¢ï¼ˆã‚¹ã‚³ã‚¢ã€ãƒ¬ãƒ™ãƒ«ã€EXPï¼‰ -->
<div id="uiTop">
  <div id="score">ã‚¹ã‚³ã‚¢: 0</div> <!-- ä¸­å¤®æƒãˆ -->

  <div id="levelExpRow">
    <span id="level">Lv.1</span>
    <span id="exp">EXP: 0 / 200</span>
  </div>
</div>
<div id="time" style="display: none;">ã‚¿ã‚¤ãƒ : 0.000ç§’</div>
<!-- ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ -->
<div id="titleScreen">
  <img src="title_mothvoid.png" alt="MOTHVOIDã‚¿ã‚¤ãƒˆãƒ«ãƒ­ã‚´" id="titleLogo">
  <p id="pressToStart">PRESS ANY BUTTON</p>
</div>
  <!-- ã‚²ãƒ¼ãƒ ç”»é¢ -->
  <div id="game">
    <div id="background"></div>
    <div id="player"></div>
    <div id="hitbox"></div>
    <div id="lives">â¤ï¸â¤ï¸â¤ï¸</div>
    <div id="screenFade"></div>
     <!-- ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ -->
    <img id="justParryEffect" src="eff_just_parry.gif"
       style="display: none; position: absolute; width: 60px; height: 60px; z-index: 3; pointer-events: none;">
    <!-- BGM -->
    <audio id="bgm_stage1" loop><source src="bgm_stage1.mp3" type="audio/mpeg"></audio>
    <audio id="bgm_stage2" loop><source src="bgm_stage2.mp3" type="audio/mpeg"></audio>
    <audio id="bgm_stage3" loop><source src="bgm_stage3.mp3" type="audio/mpeg"></audio>
    <audio id="bgm_final" loop><source src="bgm_final.mp3" type="audio/mpeg"></audio>
    <!-- SE -->
    <audio id="seParry"><source src="se_parry.mp3" type="audio/mpeg"></audio>
    <audio id="seDodge"><source src="se_dodge.mp3" type="audio/mpeg"></audio>
    <audio id="seBombL"><source src="se_bomb_L.mp3" type="audio/mpeg"></audio>
    <audio id="seItem"><source src="se_item.mp3" type="audio/mpeg"></audio>
    <audio id="seJustParry"><source src="se_justparry.mp3" type="audio/mpeg"></audio>
    <!-- ã‚¯ãƒªã‚¢ç”»é¢ -->
    <div id="gameClear">
      <div>
        <h2 id="thankYouText">Thank you for playing!</h2>
        <p id="timeRating"></p>
        <p id="credits">
          <span>Director: akky</span><br>
          <span>Designer: MAS</span><br>
          <span>Programmer: GPT</span><br>
          <span>MOTHVOID 2025/7/01</span>
        </p>
      </div>
    </div>

    <!-- ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç”»é¢ -->
    <div id="gameOver">
      <h2>Game Over</h2>
    </div>
  </div>

    <!-- ã‚¿ãƒƒãƒæ“ä½œãƒœã‚¿ãƒ³ -->
<div id="touchControls" class="title-only">
  <div class="arrowGroup">
    <div id="moveInstruction" class="instruction title-only">å·¦å³ç§»å‹•ï¼é€£ç¶šå…¥åŠ›ã§å›é¿</div>
    <img id="btnLeft" src="btn_left.png" class="control-button">
    <img id="btnRight" src="btn_right.png" class="control-button">
  </div>
  <div class="parryGroup">
    <div id="parryInstruction" class="instruction title-only">ãƒ‘ãƒªã‚£ï¼ã‚¸ãƒ£ã‚¹ãƒˆãƒ‘ãƒªã‚£</div>
    <img id="btnParry" src="btn_parry.png" class="control-button">
  </div>

  <button id="restartButton">å†ãƒ—ãƒ¬ã‚¤</button>

<script>
  const game = document.getElementById("game");
  const player = document.getElementById("player");
  const hitbox = document.getElementById("hitbox");
  const scoreEl = document.getElementById("score");
  const livesEl = document.getElementById("lives");
  const timeEl = document.getElementById("time");
  const levelEl = document.getElementById("level");
  const expEl = document.getElementById("exp");
  const gameClear = document.getElementById("gameClear");
  const timeRatingEl = document.getElementById("timeRating");
  const restartButton = document.getElementById("restartButton");
  const bgmStage1 = document.getElementById("bgm_stage1");
  const bgmStage2 = document.getElementById("bgm_stage2");
  const bgmStage3 = document.getElementById("bgm_stage3");
  const bgmFinal = document.getElementById("bgm_final");
  const seParry = document.getElementById("seParry");
  const seBombL = document.getElementById("seBombL");
  const seDodge = document.getElementById("seDodge");
  const seItem = document.getElementById("seItem");
  const seJustParry = document.getElementById("seJustParry");
  const btnLeft  = document.getElementById("btnLeft");
  const btnRight = document.getElementById("btnRight");
  const btnParry = document.getElementById("btnParry");

  let score = 0;
  let lives = 3;
  let maxLives = 3;
  let gameOver = false;
  let invincible = false;
  let parryActive = false;
  let justParry = false;
  let playerX = 180;
  let playerSpeed = 3;
  let obstacleSpeed = 15;  // éšœå®³ç‰©ã®é€Ÿåº¦
  let startTime = Date.now();  // ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã®æ™‚é–“
  let gameTime = 0;  // çµŒéæ™‚é–“ï¼ˆãƒŸãƒªç§’ï¼‰
  let lastScoreUpdateTime = 0;  // æœ€å¾Œã«ã‚¹ã‚³ã‚¢ã‚’æ›´æ–°ã—ãŸãƒŸãƒªç§’
  let highScore = localStorage.getItem("highScore") || 0;
  let parryGauge = 0;
  const maxGauge = 3;
  let level = 1;
  let exp = 0;
  const allObstacles = [];
  let stage = 1;
  let lastParryTime   = 0;   // å‰å›ãƒ‘ãƒªã‚£ã‚’æ‰“ã£ãŸã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
  const PARRY_COOLDOWN = 600; // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³æ™‚é–“ [ms]
  let firstInteraction = false;
  let currentBGM = null;
  let gameStarted = false;
  let gamePaused = false;
  const scrollDuration = 120; // èƒŒæ™¯ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é€Ÿåº¦ï¼ˆç§’ï¼‰
  let baseInterval   = 800;  // â˜… ç¾åœ¨ã®é–“éš”ï¼ˆåˆæœŸ 800msï¼‰
  let obstacleTimerId      = null; // â˜… setInterval ã® ID ã‚’ä¿æŒ
  let obstacleSpawnInterval = null;

  // å›é¿ç§»å‹•é–¢é€£ã®å¤‰æ•°
  let lastKey        = "";      // ç›´å‰ã®æ–¹å‘ã‚­ãƒ¼
  let lastKeyTime    = 0;       // æŠ¼ä¸‹ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
  let isDodging      = false;   // å›é¿ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ä¸­
  let speedBoost     = false;   // å›é¿å¾Œ 0.3 s ã ã‘ 2 å€é€Ÿ
  let keyPressed = {};  // æŠ¼ä¸‹ä¸­ã‹ã©ã†ã‹

  const DOUBLE_TAP_MS = 200;    // 0.2 ç§’ä»¥å†…
  const STEP_PX       = 30;     // 1 ã‚¹ãƒ†ãƒƒãƒ—è·é›¢

/* =======================================================
   â–¼ ã‚²ãƒ¼ãƒ é–‹å§‹ï¼å†ã‚¹ã‚¿ãƒ¼ãƒˆå‡¦ç†ï¼ˆBGMãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³å¯¾å¿œï¼‰
   ======================================================= */

// ã‚¿ã‚¤ãƒãƒ¼IDã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å®šç¾©
let obstacleGenerationInterval;
let scoreUpdateInterval;
let timeUpdateInterval;

// BGM ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³å†ç”Ÿé–¢æ•°ï¼ˆvolume 0 â†’ 1ï¼‰
function fadeInBGM(audio, duration = 1000) {
  const target = parseFloat(audio.dataset.targetVolume || 1);   // â˜… è¿½åŠ 
  audio.volume = 0;
  audio.currentTime = 0;
  audio.play().catch(console.warn);

  const step = target / (duration / 50);
  const id = setInterval(() => {
    audio.volume = Math.min(target, audio.volume + step);        // â˜… target ã¾ã§
    if (audio.volume >= target) {
      clearInterval(id);
      currentBGM = audio;
    }
  }, 50);
}

/* =======================================================
   â–¼ BGM ã‚¯ãƒ­ã‚¹ãƒ•ã‚§ãƒ¼ãƒ‰ ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
   ======================================================= */
function crossfadeBGM(fromAudio, toAudio, duration = 1500) {
  if (!fromAudio || !toAudio || fromAudio === toAudio) return;

  const fromTarget = 0;
  const toTarget   = parseFloat(toAudio.dataset.targetVolume || 1);  // â˜… è¿½åŠ 

  const stepTime = 50;
  const steps    = duration / stepTime;
  const fromStep = (fromAudio.volume - fromTarget) / steps;
  const toStep   =  toTarget               / steps;

  toAudio.volume = 0;
  toAudio.currentTime = 0;
  toAudio.play().catch(console.warn);

  let n = 0;
  const id = setInterval(() => {
    n++;
    fromAudio.volume = Math.max(fromTarget, fromAudio.volume - fromStep);
    toAudio.volume   = Math.min(toTarget , toAudio.volume   + toStep );

    if (n >= steps) {
      clearInterval(id);
      fromAudio.pause();
      fromAudio.volume = parseFloat(fromAudio.dataset.targetVolume || 1);
      currentBGM = toAudio;
    }
  }, stepTime);
}

/* =======================================================
   â–¼ èƒŒæ™¯ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é€Ÿåº¦
   ======================================================= */
let backgroundOffset = 0;
let scrollSpeed = 0.2; // ã‚¹ãƒ†ãƒ¼ã‚¸ã”ã¨ã«å¤‰åŒ–ã™ã‚‹é€Ÿåº¦

function scrollBackground() {
  backgroundOffset += scrollSpeed;
  const bg = document.getElementById("background");

  // background-position-y ã‚’ã€Œ%ã€ã§ã¯ãªãã€Œpxã€å˜ä½ã§æ‰±ã„ã€è‡ªç„¶ãªãƒ«ãƒ¼ãƒ—ã«
  bg.style.backgroundPositionY = `${backgroundOffset}px`;

  requestAnimationFrame(scrollBackground);
}

function setStageBackgroundSpeed(stage) {
  if (stage === 1) scrollSpeed = 0.3;
  else if (stage === 2) scrollSpeed = 0.5;
  else if (stage === 3) scrollSpeed = 0.8;
  else if (stage === 4) scrollSpeed = 2.0;
}

/* =======================================================
   â–¼ èƒŒæ™¯ & BGM ã‚¯ãƒ­ã‚¹ãƒ•ã‚§ãƒ¼ãƒ‰ä»˜ãã‚¹ãƒ†ãƒ¼ã‚¸ç®¡ç†
   ======================================================= */

/** èƒŒæ™¯â€BGM ã‚¯ãƒ­ã‚¹ãƒ•ã‚§ãƒ¼ãƒ‰ã®æ‰€è¦æ™‚é–“ï¼ˆmsï¼‰ */
const FADE_MS = 1500;          // â†BGM ã® crossfadeBGM() ã¨æƒãˆã¦ã„ã¾ã™

/**
 * æš—è»¢ â†’ èƒŒæ™¯ç”»åƒåˆ‡æ›¿ â†’ æ˜è»¢
 * @param {number} nextStage 1ã€œ4
 */
function crossfadeBackground(nextStage){
  const bg    = document.getElementById("background");   // <div id="background">
  const shade = document.getElementById("screenFade");   // <div id="screenFade">

  /* --- æš—è»¢é–‹å§‹ --- */
  shade.style.transition = `opacity ${FADE_MS/2}ms ease`;
  shade.style.opacity    = 1;

  /* --- æš—è»¢ãŒåŠåˆ†çµ‚ã‚ã£ãŸã‚‰ç”»åƒå·®ã—æ›¿ãˆã€å³ãƒ»æ˜è»¢ --- */
  setTimeout(()=>{
    bg.style.backgroundImage = `url(env_stage${nextStage}.png)`; // ä¾‹: env_stage3.png
    shade.style.opacity = 0;                                     // æ˜è»¢
  }, FADE_MS/2);
}

/* =======================================================
   â–¼ èƒŒæ™¯æƒ…å ±æ›´æ–°
   ======================================================= */
function updateBackgroundInstant(stageNum) {
  const bg = document.getElementById("background");

  // èƒŒæ™¯ç”»åƒã‚’å³æ™‚åˆ‡æ›¿
  bg.style.backgroundImage = `url(env_stage${stageNum}.png)`; // ä¾‹: env_stage2.png

  // å¿…è¦ãªåˆæœŸã‚¹ã‚¿ã‚¤ãƒ«å†è¨­å®šï¼ˆå¿µã®ãŸã‚ãƒªã‚»ãƒƒãƒˆï¼‰
  bg.style.backgroundRepeat = "repeat-y";
  bg.style.backgroundSize = "100% auto";
  bg.style.backgroundPositionY = `${backgroundOffset}px`; // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä½ç½®ã«åˆã‚ã›ã‚‹
}
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     ã‚¹ãƒ†ãƒ¼ã‚¸åˆ¤å®š &  ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«/BGM åŒæœŸã‚¯ãƒ­ã‚¹ãƒ•ã‚§ãƒ¼ãƒ‰
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function checkStage(){
  const prev = stage;
  stage =
    score >= 150000 ? 4 :
    score >= 100000 ? 3 :
    score >=  50000 ? 2 : 1;

  /* â”€ ã‚¹ãƒ†ãƒ¼ã‚¸ãŒå¤‰ã‚ã£ãŸã‚‰ â”€ */
  if (stage !== prev){

    /* èƒŒæ™¯ã‚’ã‚¯ãƒ­ã‚¹ãƒ•ã‚§ãƒ¼ãƒ‰ */
    crossfadeBackground(stage);

    /* BGM ã‚‚ã‚¯ãƒ­ã‚¹ãƒ•ã‚§ãƒ¼ãƒ‰ */
    const targetBGM = [bgmStage1, bgmStage2, bgmStage3, bgmFinal][stage - 1];

    if (!currentBGM){
      // åˆå›ã ã‘ã¯ãƒœãƒªãƒ¥ãƒ¼ãƒ  0â†’1 ã®ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ã§é–‹å§‹
      fadeInBGM(targetBGM, FADE_MS);
    }else if (currentBGM !== targetBGM){
      crossfadeBGM(currentBGM, targetBGM, FADE_MS);
    }

    currentBGM = targetBGM;
    setStageBackgroundSpeed(stage); // â† ã“ã“ã§èƒŒæ™¯ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é€Ÿåº¦ã‚’å¤‰æ›´
  }
}


/* =======================================================
   â–¼ ãƒ¡ã‚¤ãƒ³ã‚²ãƒ¼ãƒ é–‹å§‹å‡¦ç†
   ======================================================= */
function startGame() {
  if (!gameOver && firstInteraction) return;
  firstInteraction = true;
    // ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢éè¡¨ç¤º
  const titleScreen = document.getElementById("titleScreen");
  if (titleScreen) {
    titleScreen.style.display = "none";
    document.getElementById("moveInstruction").style.display = "none";
    document.getElementById("parryInstruction").style.display = "none";
  }
  
   allObstacles.forEach(obj => obj.remove());
  allObstacles.length = 0;
  scrollBackground();
  
  /* â˜…â˜…â˜…â˜…â˜… ã“ã“ã‹ã‚‰éŸ³é‡ãƒ—ãƒªã‚»ãƒƒãƒˆ â˜…â˜…â˜…â˜…â˜… */
  const BGM_VOLUME = 0.7;   // â† å¥½ã¿ã«åˆã‚ã›ã¦æ•°å€¤ã‚’å¤‰ãˆã‚‹
  const SE_VOLUME  = 0.8;   // â† SE å…¨èˆ¬ã®åŸºæœ¬éŸ³é‡

  // å¿…è¦ãª SE ãŒå¢—ãˆãŸã‚‰é…åˆ—ã«è¿½åŠ ã—ã¦ä¸‹ã•ã„
  [seParry, seDodge, seBombL, seItem, seJustParry].forEach(se => se.volume = SE_VOLUME);

  // BGM ã¯ fadeInBGM / crossfadeBGM å†…ã§ targetVolume ã‚’èª­ã‚€ã‚ˆã†ã«ã™ã‚‹
  [bgmStage1, bgmStage2, bgmStage3, bgmFinal].forEach(bgm => {
    bgm.dataset.targetVolume = BGM_VOLUME;   // <- ç›®æ¨™éŸ³é‡ã‚’è¨˜æ†¶
  });
  /* â˜…â˜…â˜…â˜…â˜… ã“ã“ã¾ã§éŸ³é‡ãƒ—ãƒªã‚»ãƒƒãƒˆ â˜…â˜…â˜…â˜…â˜… */
  
  // èƒŒæ™¯ç”»åƒã‚’å³è¡¨ç¤ºï¼ˆã‚²ãƒ¼ãƒ é–‹å§‹ç›´å¾Œã«1æšç›®ã‚’è¡¨ç¤ºï¼‰
  updateBackgroundInstant(1); 
  
  // å¤‰æ•°åˆæœŸåŒ–
  gameOver = false;
  gameStarted = true; 
  score = 0;
  lives = maxLives = 3;
  stage = 1;
  parryGauge = 0;
  startTime = Date.now();
  resetObstacleSpawn(); // â† ã“ã“ã ã‘ã«ã™ã‚‹ 

  // UI åˆæœŸåŒ–
  gameClear.style.display = "none";
  restartButton.style.display = "none";
  updateUI();

  // BGM åˆæœŸåŒ–ã¨å†ç”Ÿ
  [bgmStage1, bgmStage2, bgmStage3, bgmFinal].forEach(bgm => {
    bgm.pause();
    bgm.currentTime = 0;
    bgm.volume = 0;
  });
  bgmStage1.volume = 1;
  currentBGM = bgmStage1;
  fadeInBGM(currentBGM, 1000);

  // ã‚¿ã‚¤ãƒãƒ¼å†è¨­å®š
  clearInterval(obstacleGenerationInterval);
  clearInterval(scoreUpdateInterval);
  clearInterval(timeUpdateInterval);

  scoreUpdateInterval = setInterval(updateScore, 100);
  timeUpdateInterval = setInterval(updateTime, 30);
}

// æœ€åˆã®å…¥åŠ›ã§èµ·å‹•
window.addEventListener("mousedown", startGame, { once: true });
window.addEventListener("keydown",   startGame, { once: true });
restartButton.addEventListener("click", startGame);

// å†ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³å‡¦ç†
restartButton.addEventListener("click", startGame);

/* =======================================================
   â–¼ éšœå®³ç‰©ä½œæˆãƒªã‚»ãƒƒãƒˆå‡¦ç†
   ======================================================= */
function resetObstacleSpawn() {
  if (obstacleSpawnInterval !== null) {
    clearInterval(obstacleSpawnInterval);
    console.log("æ—¢å­˜ã®spawnIntervalåœæ­¢");
  }

  obstacleSpawnInterval = setInterval(() => {
    if (!gameOver) createObstacle();
  }, baseInterval);

  console.log(`[resetObstacleSpawn] baseInterval = ${baseInterval}`);
}

/* =======================================================
   â–¼ éšœå®³ç‰©ä½œæˆå‡¦ç†
   ======================================================= */
function createObstacle() {
  if (gameOver) return;
  const item = document.createElement("div");
  item.classList.add("obstacle");

  let sizeOption;
  let colorClass = "";
  let fallSpeed;

  // speedScaleã‚’scoreã«åŸºã¥ã„ã¦è¨ˆç®—
  let speedScale = 1.0;
  if (score >= 150000) {
    const additionalScale = Math.min(Math.floor(score / 150000) * 1.5, 6.0);
    speedScale += additionalScale;
  }
  speedScale = Math.min(speedScale, 10.0);

  // ã‚¹ãƒ†ãƒ¼ã‚¸åˆ¥å‡ºç¾å†…å®¹
  if (stage === 1) {
    sizeOption = Math.random() < 0.6 ? "small" : "big";
    colorClass = "red";
    fallSpeed = sizeOption === "small" ? 4 * speedScale : 3 * speedScale;
  } else if (stage === 2) {
    sizeOption = Math.random() < 0.7 ? "small" : "big";
    colorClass = "blue";
    fallSpeed = sizeOption === "small" ? 4 * speedScale : 5 * speedScale;
  } else if (stage === 3) {
    sizeOption = Math.random() < 0.8 ? "big" : "huge";
    colorClass = "green";
    fallSpeed = sizeOption === "big" ? 5 * speedScale : 2 * speedScale;
  } else if (stage === 4) {
    const randomChoice = Math.random();
    if (randomChoice < 0.3) {
      sizeOption = "huge";
      colorClass = "red";
      fallSpeed = 3 * speedScale;
    } else if (randomChoice < 0.4) {
      sizeOption = "huge";
      colorClass = "blue";
      fallSpeed = 2 * speedScale;
    } else {
      sizeOption = "small";
      colorClass = "green";
      fallSpeed = 6 * speedScale;
    }
    item.classList.add("stage4");
  }

  // â–¼ GIFç”»åƒã®è¡¨ç¤º
  const img = document.createElement("img");
  const sizeStr = sizeOption;
  const colorInitial = colorClass[0].toUpperCase();
  img.src = `enm_${sizeStr}_${colorInitial}.gif`;
  img.className = "obstacle-img";

  if (sizeOption === "small") {
    img.style.width = "60px";
    img.style.height = "60px";
  } else if (sizeOption === "big") {
    img.style.width = "100px";
    img.style.height = "100px";
  } else {
    img.style.width = "180px";
    img.style.height = "180px";
  }

  img.style.position = "absolute";
  img.style.left = "50%";
  img.style.top = "50%";
  img.style.transform = "translate(-50%, -50%)";
  img.style.pointerEvents = "none";
  item.appendChild(img);

  // è¡¨ç¤ºã‚µã‚¤ã‚ºï¼ˆãƒ’ãƒƒãƒˆãƒœãƒƒã‚¯ã‚¹ã‚‚å®šç¾©ï¼‰
  if (sizeOption === "small") {
    item.style.width = "60px";
    item.style.height = "60px";
    item.dataset.hitboxW = 60;
    item.dataset.hitboxH = 60;
  } else if (sizeOption === "big") {
    item.style.width = "92px";
    item.style.height = "92px";
    item.dataset.hitboxW = 92;
    item.dataset.hitboxH = 92;
  } else if (sizeOption === "huge") {
    item.style.width = "172px";
    item.style.height = "172px";
    item.dataset.hitboxW = 172;
    item.dataset.hitboxH = 172;
  }

  item.style.background = "none";
  item.style.backgroundColor = "transparent";

  // ã‚³ãƒªã‚¸ãƒ§ãƒ³æƒ…å ±
  const hp = sizeOption === "small" ? 1 : sizeOption === "big" ? 2 : 3;
  item.dataset.hp = hp;
  item.dataset.type = "damage";
  item.dataset.stage = stage;

  item.classList.add("obstacle");
//item.classList.add("debug");

  // è¡¨ç¤ºä½ç½®ï¼ˆ40pxã‚°ãƒªãƒƒãƒ‰ï¼‰
  item.style.left = Math.floor(Math.random() * 9) * 40 + "px";
  item.style.top = "0px";

  game.appendChild(item);
  allObstacles.push(item);

  let y = 0;
  const fall = setInterval(() => {
    if (gameOver || !item.parentElement) return clearInterval(fall);
    y += fallSpeed;
    item.style.top = y + "px";

    const playerRect = hitbox.getBoundingClientRect();
    const itemRect = item.getBoundingClientRect();

    // ãƒ‘ãƒªã‚£åˆ¤å®š
    if (parryActive && item.dataset.type === "damage") {
      if (checkCollision(playerRect, itemRect)) {
        const isJust = justParry;
        parryGauge++;
        if (parryGauge > maxGauge) parryGauge = maxGauge;
        reflectObstacle(item, isJust);
        updateUI();
        clearInterval(fall);
        return;
      }
    }

    // é€šå¸¸ãƒ’ãƒƒãƒˆ
    if (checkCollision(playerRect, itemRect)) {
      if (!invincible) {
        const dmg = parseInt(item.dataset.hp);
        lives -= dmg;
        if (lives <= 0) endGame();
        setInvincible();
      }
      item.remove();
      updateUI();
      clearInterval(fall);
      return;
    }
    // ç”»é¢å¤–ã¸ã§ãªã„
    if (y > 600) {
      item.remove();
      clearInterval(fall);
    }
  }, 30);
}

/** â˜… æŒ‡å®šãƒŸãƒªç§’ã§éšœå®³ç‰©ç”Ÿæˆã‚¿ã‚¤ãƒãƒ¼ã‚’å†ã‚»ãƒƒãƒˆ */
function setObstacleTimer(interval) {
  clearInterval(obstacleTimerId);
  obstacleTimerId = setInterval(() => {
    if (!gameOver) createObstacle();
  }, interval); // â† interval ã¯ baseInterval ã‚’å—ã‘å–ã‚‹ã¯ãš
}

//åˆæœŸéšœå®³ç‰©ç™ºç”Ÿé–“éš”
/* ==== ã‚¹ã‚³ã‚¢ã«å¿œã˜ã¦ç”Ÿæˆé–“éš”ã‚’æ›´æ–° ==== */
function startObstacleGeneration(){
  // åˆå›èµ·å‹•
  setObstacleTimer(800);
}

/** â˜… ã‚¹ã‚³ã‚¢æ›´æ–°ã”ã¨ã«å‘¼ã¶ï¼ˆupdateScore å†…ã®æœ€å¾Œã«ï¼‘è¡Œè¿½åŠ ã™ã‚Œã°ï¼¯ï¼«ï¼‰ */
function updateObstacleIntervalByScore(score) {
  const newInterval = Math.max(200, 800 - Math.floor(score / 200000) * 200); // â† ã“ã‚ŒãŒå¿…è¦ï¼
  const previousInterval = baseInterval;

  if (newInterval !== baseInterval) {
    baseInterval = newInterval;
    console.log(`[ã‚¹ã‚³ã‚¢æ›´æ–°] score=${score}, baseIntervalå¤‰æ›´: ${previousInterval} â†’ ${baseInterval}`);
    resetObstacleSpawn();
  }
}

/* =======================================================
   â–¼ ã‚¹ãƒ†ãƒ¼ã‚¸é€²è¡Œ
   ======================================================= */
function updateStage() {
  const prev = stage;

  if (score >= 150000) {
    stage = 4;
  } else if (score >= 100000) {
    stage = 3;
  } else if (score >=  50000) {
    stage = 2;
  } else {
    stage = 1;
  }

  if (stage !== prev) {
    crossfadeBackground(stage);          // èƒŒæ™¯ã®ã‚¯ãƒ­ã‚¹ãƒ•ã‚§ãƒ¼ãƒ‰
    setStageBackgroundSpeed(stage);      // â¬…ï¸ ã“ã‚Œã‚’è¿½åŠ ï¼ˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é€Ÿåº¦åˆ‡æ›¿ï¼‰
  }
}

/* =======================================================
   â–¼ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¡Œå‹•å‡¦ç†
   ======================================================= */
// å›é¿ç§»å‹•é–¢æ•°
function dodge(dir) {
  if (isDodging) return;
  isDodging = true;
  speedBoost = true;
    // ğŸ”Š å›é¿SEã‚’å†ç”Ÿ
  if (seDodge) {
    seDodge.currentTime = 0;
    seDodge.play();
  }
  setInvincible(300);  // ç„¡æ•µæ™‚é–“
  player.classList.add("dodging");

  // ğŸ”µ é’ã„å…‰ã‚’ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«è¿½åŠ 
  const flare = document.createElement("div");
  flare.className = "dodge-flare";
  player.appendChild(flare);

  const startX = playerX;
  spawnAfterImage(startX); // 1ã‚¹ãƒ†ãƒƒãƒ—ç›®ã®å‰

  for (let i = 0; i < 2; i++) {
    const delta = dir === "ArrowLeft" ? -STEP_PX : STEP_PX;
    playerX = Math.max(0, Math.min(360, playerX + delta));
    player.style.left = playerX + "px";
    hitbox.style.left = (playerX + 4) + "px";

    if (i === 0) spawnAfterImage(playerX); // 1ã‚¹ãƒ†ãƒƒãƒ—å¾Œã®æ®‹åƒ
  }

  setTimeout(() => {
    speedBoost = false;
    isDodging = false;
    player.classList.remove("dodging");
    flare.remove(); // ğŸ”µ é’ã„å…‰ã‚’é™¤å»
  }, 300);
}

/* æ®‹åƒç”Ÿæˆ 0.1 s */
function spawnAfterImage(xPos){
  const img = document.createElement("div");
  img.className = "afterimage";
  img.style.left = xPos + "px";
  img.style.bottom = "10px";
  img.style.backgroundImage = 'url("chr_moth.gif")';
  img.style.backgroundSize = 'cover';
  game.appendChild(img);
  setTimeout(() => img.remove(), 100);
}

/* â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…  å…¥åŠ›ãƒãƒ³ãƒ‰ãƒ©ã“ã“ã‹ã‚‰  â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   - âŒ¨  â† â†’ / Aãƒ»Dï¼šæŠ¼ã—ã£ã±ã§é€šå¸¸ç§»å‹•ã€0.2s ä»¥å†…ã® 2 å›æŠ¼ã—ã§ dodge()
   - ğŸ–±  ã‚¯ãƒªãƒƒã‚¯  ï¼šparry
   - ğŸ¤š ã‚¿ãƒƒãƒ     ï¼šå·¦ãƒ»å³ãƒ»ãƒ‘ãƒªã‚£
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function stepMove(dir){
  if (gameOver) return;
  const delta = speedBoost ? playerSpeed * 2 : playerSpeed;

  if (dir === "ArrowLeft")  playerX = Math.max(0,   playerX - delta);
  if (dir === "ArrowRight") playerX = Math.min(360, playerX + delta);

  player.style.left = playerX + "px";
  hitbox.style.left = (playerX + 4) + "px";
}

let isTouchHolding = false;

function handleTap(dirKey){
  const now = performance.now();

  // ğŸ›‘ æŠ¼ã—ã£ã±ä¸­ã¯ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ã‚’ç„¡è¦–
  if (isTouchHolding) return;

  if (lastKey === dirKey && now - lastKeyTime <= DOUBLE_TAP_MS){
    dodge(dirKey);
    lastKey = "";
  } else {
    lastKey     = dirKey;
    lastKeyTime = now;
    stepMove(dirKey);
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
document.addEventListener("keydown", e=>{
  if (gameOver) return;

  const key = e.key;

  /* æ–¹å‘å…¥åŠ›ã ã‘æ‰±ã† */
  const isLeft  = key === "ArrowLeft"  || key === "a" || key === "A";
  const isRight = key === "ArrowRight" || key === "d" || key === "D";
  if (!isLeft && !isRight) return;

  const dirKey = (isLeft ? "ArrowLeft" : "ArrowRight");
  keyPressed[dirKey] = true;

  if (e.repeat){
    // OS ã‚­ãƒ¼ãƒªãƒ”ãƒ¼ãƒˆï¼šãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—åˆ¤å®šã¯è¡Œã‚ãšé€£ç¶šç§»å‹•ã ã‘
    stepMove(dirKey);
  } else {
    handleTap(dirKey);            // åˆå›æŠ¼ä¸‹ï¼šé€šå¸¸ or ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—åˆ¤å®š
  }
});

document.addEventListener("keyup", e=>{
  const key = e.key;
  if (key === "ArrowLeft"  || key === "a" || key === "A") keyPressed["ArrowLeft"]  = false;
  if (key === "ArrowRight" || key === "d" || key === "D") keyPressed["ArrowRight"] = false;
});

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ã‚¯ãƒªãƒƒã‚¯ â†’ ãƒ‘ãƒªã‚£ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
game.addEventListener("mousedown", ()=>{
  if (gameOver) return;
  activateParry();
});

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ã‚¿ãƒƒãƒ UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
let touchHoldInterval = null;

function startTouchHold(dirKey) {
  stopTouchHold(); // å‰ã®ãƒ«ãƒ¼ãƒ—ã‚’æ­¢ã‚ã‚‹
  isTouchHolding = true; // â†è¿½åŠ 
  keyPressed[dirKey] = true;
  touchHoldInterval = setInterval(() => {
    stepMove(dirKey);
  }, 30);
}

function stopTouchHold() {
  clearInterval(touchHoldInterval);
  touchHoldInterval = null;
  keyPressed["ArrowLeft"] = false;
  keyPressed["ArrowRight"] = false;
  isTouchHolding = false; // â†è¿½åŠ 
}

// ã‚¹ãƒãƒ›ç”¨ç§»å‹•ãƒœã‚¿ãƒ³ï¼ˆæŠ¼ã—ã£ã±å¯¾å¿œï¼‰
btnLeft.addEventListener("touchstart", e => {
  e.preventDefault();
  isTouchHolding = false;
  keyPressed["ArrowLeft"] = true;
  handleTap("ArrowLeft");
});
btnLeft.addEventListener("touchend", () => {
  isTouchHolding = true;
  keyPressed["ArrowLeft"] = false;
});
btnLeft.addEventListener("touchcancel", () => {
  isTouchHolding = false;
  keyPressed["ArrowLeft"] = false;
});

btnRight.addEventListener("touchstart", e => {
  e.preventDefault();
  isTouchHolding = false;
  keyPressed["ArrowRight"] = true;
  handleTap("ArrowRight");
});

btnRight.addEventListener("touchend", () => {
  isTouchHolding = true;
  keyPressed["ArrowRight"] = false;
});

btnRight.addEventListener("touchcancel", () => {
  isTouchHolding = false;
  keyPressed["ArrowRight"] = false;
});

// ã‚¹ãƒãƒ›ç”¨ãƒ‘ãƒªã‚£ãƒœã‚¿ãƒ³ï¼ˆå˜ç™ºã‚¿ãƒƒãƒ—ã§OKï¼‰
btnParry.addEventListener("touchstart", e => {
  e.preventDefault();
  activateParry();
});

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ æŠ¼ã—ã£ã±åˆ¤å®šãƒ«ãƒ¼ãƒ— â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   30ms ã”ã¨ã« keyPressed ã‚’è¦‹ã¦ç¶™ç¶šç§»å‹•ã•ã›ã‚‹ã€‚
   ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—åˆ¤å®šã«ã¯å½±éŸ¿ã—ãªã„ã€‚                */
setInterval(() => {
  if (isTouchHolding && keyPressed["ArrowLeft"])  stepMove("ArrowLeft");
  if (isTouchHolding && keyPressed["ArrowRight"]) stepMove("ArrowRight");
}, 30);

/* â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…  å…¥åŠ›ãƒãƒ³ãƒ‰ãƒ©ã“ã“ã¾ã§  â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜… */

  // ã‚¿ã‚¤ãƒ ã®æ›´æ–°ï¼ˆãƒŸãƒªç§’å˜ä½ï¼‰
  function updateTime() {
    if (gameOver) return; // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ™‚ã«ã¯ã‚¿ã‚¤ãƒ æ›´æ–°ã—ãªã„
    gameTime = (Date.now() - startTime);  // ãƒŸãƒªç§’å˜ä½ã§çµŒéæ™‚é–“ã‚’å–å¾—
    timeEl.innerHTML = `ã‚¿ã‚¤ãƒ : ${(gameTime / 1000).toFixed(3)}ç§’`;  // å°æ•°ç‚¹ä»¥ä¸‹3æ¡ã§è¡¨ç¤º
  }

// ã‚¹ã‚³ã‚¢ã®æ›´æ–° â”€ 100ms ã”ã¨ã« +10 åŠ ç®—ã—æ•´æ•°ã§è¡¨ç¤º & ã‚¹ãƒ†ãƒ¼ã‚¸/BGM åˆ¤å®šã‚‚å®Ÿæ–½
function updateScore() {
  if (gameOver) return;                       // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ä¸­ã¯æ›´æ–°ã—ãªã„

  const elapsed = Date.now() - startTime;     // çµŒéãƒŸãƒªç§’
  const tick    = Math.floor(elapsed / 100);  // 100ms å˜ä½ã®ã‚«ã‚¦ãƒ³ã‚¿

  // 100ms é€²ã‚“ã ã‚‰ã‚¹ã‚³ã‚¢åŠ ç®—
  if (tick > lastScoreUpdateTime) {
    lastScoreUpdateTime = tick;
    score += 10;

    /* â–¼ ã“ã“ã§ã‚¹ãƒ†ãƒ¼ã‚¸åˆ‡ã‚Šæ›¿ãˆ & BGM ã‚¯ãƒ­ã‚¹ãƒ•ã‚§ãƒ¼ãƒ‰ã‚’åˆ¤å®š */
    if (typeof checkStage === "function") {
      checkStage();   // â† äº‹å‰ã«è¿½åŠ ã—ãŸ checkStage() ã‚’å‘¼ã¶
    }

    // UI åæ˜ ï¼ˆå°æ•°ç‚¹ä»¥ä¸‹ãªã—ï¼‰
    scoreEl.textContent = "ã‚¹ã‚³ã‚¢: " + Math.floor(score);
    updateObstacleIntervalByScore(score);
  }
}

/* =======================================================
   â–¼ UIã®æ›´æ–°å‡¦ç†
   ======================================================= */
function updateUI() {
  // ãƒãƒ¼ãƒˆã®æ•°è¡¨ç¤ºï¼ˆè² ã®repeatå¯¾ç­–ã‚ã‚Šï¼‰
  livesEl.innerHTML =
    "â¤ï¸".repeat(Math.max(0, lives)) +
    "ğŸ–¤".repeat(Math.max(0, maxLives - lives));

  // ãƒ¬ãƒ™ãƒ«è¡¨ç¤º
  levelEl.textContent = "Lv. " + level;

  // çµŒé¨“å€¤è¡¨ç¤º
  if (level < 5) {
    expEl.textContent = `EXP: ${exp} / ${level * 200}`;
  } else {
    expEl.textContent = `EXP: MAX`;
  }

  // ã‚¹ã‚³ã‚¢ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
  scoreEl.textContent = "ã‚¹ã‚³ã‚¢: " + score;
}

/* =======================================================
   â–¼ çµŒé¨“å€¤è¿½åŠ 
   ======================================================= */
function addExp(amount) {
  if (level >= 5) return;
  exp += amount;
  let threshold = level * 200;

  while (exp >= threshold && level < 5) {
    exp -= threshold;
    level++;
    maxLives++;

    // ãƒ©ã‚¤ãƒ•ã‚’1å¢—ã‚„ã™ãŒã€maxLivesã‚’è¶…ãˆãªã„ã‚ˆã†ã«ã™ã‚‹
    lives = Math.min(lives + 1, maxLives);

    // æˆé•·åŠ¹æœ
    playerSpeed *= 1.05;

    // çµŒé¨“å€¤å†è¨ˆç®—
    threshold = level * 200;
  }

  updateUI(); // å¿˜ã‚Œãšã«UIæ›´æ–°
}
/* =======================================================
   â–¼ ãƒ‘ãƒªã‚£/ã‚¸ãƒ£ã‚¹ãƒˆãƒ‘ãƒªã‚£
   ======================================================= */
   function activateParry() {
  // ãƒ‘ãƒªã‚£ã®é€£å°„é˜²æ­¢ï¼ˆã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã¨ç™ºå‹•ä¸­ãƒã‚§ãƒƒã‚¯ï¼‰
  if (parryActive || Date.now() - lastParryTime < PARRY_COOLDOWN) return;
  lastParryTime = Date.now();

  seParry.play();         // åŠ¹æœéŸ³å†ç”Ÿ
  setInvincible(350);     // ç„¡æ•µæ™‚é–“ï¼ˆ0.35ç§’ï¼‰

  parryActive = true;
  justParry = false;

  // é€šå¸¸ãƒ‘ãƒªã‚£ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆeff_parry.gifï¼‰
  const effect = document.createElement("img");
  effect.src = "eff_parry.gif";
  effect.style.position = "absolute";
  effect.style.left = (player.offsetLeft + player.offsetWidth / 2 - 45) + "px";
  effect.style.top = (player.offsetTop + player.offsetHeight / 2 - 45) + "px";
  effect.style.width = "90px";
  effect.style.height = "90px";
  effect.style.pointerEvents = "none";
  effect.style.zIndex = "3";
  game.appendChild(effect);

  // é€šå¸¸ãƒ‘ãƒªã‚£ã¯0.3ç§’è¡¨ç¤º â†’ ã‚¸ãƒ£ã‚¹ãƒˆã§ãªã‘ã‚Œã°å‰Šé™¤
  setTimeout(() => {
    if (!justParry) effect.remove();
  }, 300);

  // ---------------- â‘¡ ã‚¸ãƒ£ã‚¹ãƒˆãƒ‘ãƒªã‚£åˆ¤å®š ----------------
  setTimeout(() => {
    const pRect = player.getBoundingClientRect();
    const pcx = (pRect.left + pRect.right) / 2;
    const pcy = (pRect.top + pRect.bottom) / 2;

    document.querySelectorAll(".obstacle").forEach(obs => {
      const oRect = obs.getBoundingClientRect();

      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä¸­å¿ƒã‹ã‚‰éšœå®³ç‰©ã®ã‚¨ãƒƒã‚¸ã¾ã§ã®æœ€çŸ­è·é›¢
      const dx = Math.max(oRect.left - pcx, 0, pcx - oRect.right);
      const dy = Math.max(oRect.top - pcy, 0, pcy - oRect.bottom);
      const dist = Math.hypot(dx, dy);

      if (!justParry && dist <= 45) {  // åˆ¤å®šè·é›¢ï¼š42pxä»¥å†…
        justParry = true;

        // eff_parry.gif ã‚’å‰Šé™¤
        effect.remove();
        showJustParry();  // â† ã“ã“ã§å‘¼ã¶
        
        // ---------------- â‘¢ eff_just_parry.gif ã‚’è¡¨ç¤º ----------------
        const jSize = 60;
        const j = document.createElement("img");
        j.src = "eff_just_parry.gif";
        j.style.position = "absolute";
        j.style.left = (player.offsetLeft + player.offsetWidth / 2 - jSize / 2) + "px";
        j.style.top = (player.offsetTop + player.offsetHeight / 2 - jSize / 2) + "px";
        j.style.width = jSize + "px";
        j.style.height = jSize + "px";
        j.style.pointerEvents = "none";
        j.style.zIndex = "3";
        game.appendChild(j);
        setTimeout(() => j.remove(), 600);
      }
    });
  }, 80); // åˆ¤å®šã‚¿ã‚¤ãƒŸãƒ³ã‚°

  // ---------------- â‘£ ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³è§£é™¤ ----------------
  setTimeout(() => {
    parryActive = false;
    justParry = false;
  }, PARRY_COOLDOWN);
}

/* ===== helper : eff_just_parry.gif ã‚’ 0.6s ã ã‘è¡¨ç¤º ===== */
function showJustParry() {
  const justParryEffect = document.getElementById("justParryEffect");
  if (!justParryEffect) return;

  // å†ç”Ÿä½ç½®èª¿æ•´ï¼ˆä¸­å¤®ã«è¡¨ç¤ºï¼‰
  justParryEffect.style.display = "block";
  justParryEffect.style.left = (player.offsetLeft + player.offsetWidth / 2 - justParryEffect.offsetWidth / 2) + "px";
  justParryEffect.style.top  = (player.offsetTop + player.offsetHeight / 2 - justParryEffect.offsetHeight / 2) + "px";

  // ğŸ”Š SEå†ç”Ÿï¼ˆåŠ¹æœéŸ³ï¼‰
  if (typeof seJustParry !== "undefined" && seJustParry) {
    seJustParry.currentTime = 0;
    seJustParry.play().catch(e => console.warn("JustParryéŸ³å†ç”Ÿå¤±æ•—:", e));
  }

  // 0.5ç§’å¾Œã«éè¡¨ç¤º
  setTimeout(() => {
    justParryEffect.style.display = "none";
  }, 500);
}

/* =======================================================
   â–¼ è¢«ãƒ€ãƒ¡ãƒ¼ã‚¸æ™‚ã®åŠé€æ˜å‡¦ç†
   ======================================================= */
  function setInvincible(duration = 1000) {
    invincible = true;
    player.style.opacity = "0.5";
    setTimeout(() => {
      invincible = false;
      player.style.opacity = "1";
    }, duration);
  }

/* =======================================================
   â–¼ çˆ†ç™ºç™ºç”Ÿå‡¦ç†
   ======================================================= */
function createExplosion(x, y, scoreValue = 0, isJust = false, noExplosion = false, expValue = 0) {
  // ---------- çˆ†ç™ºã‚¨ãƒ•ã‚§ã‚¯ãƒˆ ----------
  if (!noExplosion) {
    const explosion = document.createElement("img");
    explosion.src = "eff_bomb_L.gif";
    explosion.style.position = "absolute";
    explosion.style.left = x + "px";  // â† ä½™è¨ˆãª +20 å‰Šé™¤
    explosion.style.top  = y + "px";
    explosion.style.width = "100px";
    explosion.style.height = "100px";
    explosion.style.transform = "translate(-50%, -50%)";
    explosion.style.pointerEvents = "none";
    explosion.style.zIndex = "10";
    game.appendChild(explosion);
      // ğŸ”Š çˆ†ç™ºéŸ³ã‚’å†ç”Ÿ
  if (seBombL) {
    seBombL.currentTime = 0;
    seBombL.play();
  }

    setTimeout(() => explosion.remove(), 400);
  }

  // ---------- ã‚¹ã‚³ã‚¢ + çµŒé¨“å€¤è¡¨ç¤º ----------
  if (scoreValue > 0) {
    const scoreText = document.createElement("div");
    scoreText.textContent = `+${scoreValue}${expValue > 0 ? `\nEXP+${expValue}` : ""}`;
    scoreText.style.position = "absolute";
    scoreText.style.left = x + "px";       // â† ä½™è¨ˆãª +20 å‰Šé™¤
    scoreText.style.top  = (y - 10) + "px";
    scoreText.style.fontSize = "12px";     // â† ä¸€æ®µéšå°ã•ã
    scoreText.style.fontWeight = "bold";
    scoreText.style.whiteSpace = "pre";    // æ”¹è¡Œã‚ã‚Š
    scoreText.style.color = isJust ? "yellow" : "white";
    scoreText.style.zIndex = "15";
    scoreText.style.pointerEvents = "none";
    scoreText.style.transform = "translate(-50%, 0px)";
    game.appendChild(scoreText);

    // æµ®ãä¸ŠãŒã£ã¦æ¶ˆãˆã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
    let offset = 0;
    const floatUp = setInterval(() => {
      offset += 1;
      scoreText.style.transform = `translate(-50%, -${offset}px)`;
      if (offset > 50) {  // â† è¡¨ç¤ºæ™‚é–“ ç´„2ç§’ï¼ˆ40ms Ã— 50ï¼‰
        clearInterval(floatUp);
        scoreText.remove();
      }
    }, 40);
  }
}

/* =======================================================
   â–¼ éšœå®³ç‰©ãƒ€ãƒ¡ãƒ¼ã‚¸è¡¨ç¾
   ======================================================= */
  function applyHitFlash(obstacle) {
  obstacle.classList.add("hit-effect");
  setTimeout(() => {
    obstacle.classList.remove("hit-effect");
  }, 250);
} 
/* =======================================================
   â–¼ ã‚³ãƒªã‚¸ãƒ§ãƒ³åˆ¤å®š
   ======================================================= */
  function checkCollision(r1, r2) {
    return !(r1.top > r2.bottom || r1.bottom < r2.top || r1.left > r2.right || r1.right < r2.left);
  }

/* =======================================================
   â–¼ éšœå®³ç‰©åŒå£«ã®ã‚³ãƒªã‚¸ãƒ§ãƒ³åˆ¤å®š
   ======================================================= */
function rectsOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
  return (
    ax < bx + bw &&
    ax + aw > bx &&
    ay < by + bh &&
    ay + ah > by
  );
}

/* =======================================================
   â–¼ åå°„å‡¦ç†ï¼ˆåå°„ã§ãã‚‹éšœå®³ç‰©ã«å¯¾ã—ã¦åå°„ã‚’è¡Œã†ï¼‰
   ======================================================= */
function reflectObstacle(obstacle, isRainbow) {
  let hp = parseInt(obstacle.dataset.hp);
  obstacle.dataset.type = "reflected";
  obstacle.dataset.hp = hp;

  let y = parseInt(obstacle.style.top);
  let x = parseInt(obstacle.style.left);
  let vy = -obstacleSpeed * (isRainbow ? 1.5 : 1);

  if (isRainbow) obstacle.classList.add("rainbow");

  // æ‹¡å¤§ãƒ’ãƒƒãƒˆã‚µã‚¤ã‚ºã‚’ã‚»ãƒƒãƒˆï¼ˆ500msé™å®šï¼‰
  const originalW = obstacle.offsetWidth;
  const originalH = obstacle.offsetHeight;
  const expandedW = originalW * 1.2;
  const expandedH = originalH * 1.2;
  obstacle.dataset.hitboxW = expandedW;
  obstacle.dataset.hitboxH = expandedH;

  setTimeout(() => {
    if (obstacle && obstacle.parentElement) {
      obstacle.dataset.hitboxW = originalW;
      obstacle.dataset.hitboxH = originalH;
    }
  }, 500);

  const move = setInterval(() => {
    if (!obstacle.parentElement) return clearInterval(move);

    y += vy;
    obstacle.style.top = y + "px";

    const selfW = parseFloat(obstacle.dataset.hitboxW || originalW);
    const selfH = parseFloat(obstacle.dataset.hitboxH || originalH);
    const selfX = parseInt(obstacle.style.left);
    const selfY = y;

    for (let other of allObstacles) {
      if (other === obstacle || !other.parentElement) continue;

      const otherX = parseInt(other.style.left);
      const otherY = parseInt(other.style.top);
      const otherW = parseFloat(other.dataset.hitboxW || other.offsetWidth);
      const otherH = parseFloat(other.dataset.hitboxH || other.offsetHeight);

      if (!rectsOverlap(selfX, selfY, selfW, selfH, otherX, otherY, otherW, otherH)) {
        continue;
      }

      const hp1 = parseInt(obstacle.dataset.hp);
      const hp2 = parseInt(other.dataset.hp);
      const stageType = parseInt(other.dataset.stage || 1);

      let scoreAdd = 0;
      let expAdd = 0;

      if (stageType === 1 || stageType === 2) {
        scoreAdd = hp2 === 2 ? 1500 : 1000;
        expAdd = hp2 === 2 ? 15 : 10;
      } else if (stageType === 3) {
        scoreAdd = hp2 === 3 ? 2500 : 1000;
        expAdd = hp2 === 3 ? 25 : 10;
      } else if (stageType === 4) {
        const imgSrc = other.querySelector("img")?.src || "";
        if (hp2 === 3 && imgSrc.includes("enm_huge_B")) {
          scoreAdd = 8000;
          expAdd = 80;
        } else if (hp2 === 3) {
          scoreAdd = 5000;
          expAdd = 50;
        } else if (hp2 === 1) {
          scoreAdd = 2000;
          expAdd = 20;
        }
      }

      if (isRainbow) {
        // ã‚¸ãƒ£ã‚¹ãƒˆãƒ‘ãƒªã‚£
        score += scoreAdd * 2;
        addExp(expAdd);
        createExplosion(otherX, otherY, scoreAdd * 2, true, false, expAdd);
        other.remove();
      } else {
        // é€šå¸¸ãƒ‘ãƒªã‚£
        if (hp1 === hp2) {
          score += scoreAdd;
          addExp(expAdd);
          createExplosion(otherX, otherY, scoreAdd, false, false, expAdd);
          obstacle.remove();
          other.remove();
          clearInterval(move);
        } else if (hp1 > hp2) {
          score += scoreAdd;
          addExp(expAdd);
          createExplosion(otherX, otherY, scoreAdd, false, false, expAdd);
          obstacle.dataset.hp = hp1 - 1;
          other.remove();
        } else {
          other.dataset.hp = hp2 - 1;
          other.classList.add("damage-flash");
          setTimeout(() => other.classList.remove("damage-flash"), 150);
          obstacle.remove();
          clearInterval(move);
        }
      }

      updateUI();
    }

    if (y < 0) {
      obstacle.remove();
      clearInterval(move);
    }
  }, 30);
}

/* =======================================================
   â–¼ ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢æ™‚ã®è©•ä¾¡åˆ¤å®š
   ======================================================= */
function getTimeRating(score, time) {
  const scorePerTime = score / time;  // ã‚¹ã‚³ã‚¢ Ã· ã‚¿ã‚¤ãƒ ï¼ˆãƒŸãƒªç§’å˜ä½ï¼‰
let rating = '';
  
  // è©•ä¾¡åŸºæº–ï¼ˆã‚¹ã‚³ã‚¢ Ã· ã‚¿ã‚¤ãƒ  ã‚’1000åˆ†ã®1ã«ã—ãŸå ´åˆï¼‰
  if (scorePerTime >= 3.2) {
    rating = "S";
  } else if (scorePerTime >= 2.8) {
    rating = "A";
  } else if (scorePerTime >= 2.4) {
    rating = "B";
  } else if (scorePerTime >= 2.0) {
    rating = "C";
  } else if (scorePerTime >= 1.6) {
    rating = "D";
  } else {
    rating = "E";
  }

  return rating;
}

/* =======================================================
   â–¼ ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢å‡¦ç†
   ======================================================= */
function endGame() {
  gameOver = true;

  // BGMåœæ­¢
  bgmStage1.pause();
  bgmStage2.pause();
  bgmStage3.pause();
  bgmFinal.pause();

  // æ—¢ã«è¿½åŠ ã•ã‚ŒãŸGame Overãƒ†ã‚­ã‚¹ãƒˆãŒã‚ã‚Œã°å‰Šé™¤
  const existingOver = document.getElementById("gameOverText");
  if (existingOver) existingOver.remove();

  clearInterval(obstacleTimerId);

  // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼å‡¦ç†
  if (score < 150000) {
    const gameOverText = document.createElement("h2");
    gameOverText.id = "gameOverText";   
    gameOverText.textContent = "Game Over!";
    gameOverText.style.color = "yellow";
    gameOverText.style.marginTop = "200px";
    game.appendChild(gameOverText);

    gameClear.style.display = "none";
    restartButton.style.display = "block";
    restartButton.onclick = () => location.reload();

  } else {
    // â–¼â–¼â–¼ã€ã“ã“ã«éšœå®³ç‰©å‰Šé™¤å‡¦ç†ã‚’è¿½åŠ ã€‘â–¼â–¼â–¼
    allObstacles.forEach(obj => obj.remove());
    allObstacles.length = 0;

    // ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢å‡¦ç†
    const clearTime = (gameTime / 1000).toFixed(3);
    const rating = getTimeRating(score, gameTime);

    console.log("ã‚¹ã‚³ã‚¢:", score);
    console.log("ã‚²ãƒ¼ãƒ ã‚¿ã‚¤ãƒ ï¼ˆç§’ï¼‰:", clearTime);
    console.log("ã‚¹ã‚³ã‚¢ Ã· ã‚¿ã‚¤ãƒ :", score / gameTime);
    console.log("è©•ä¾¡:", rating);

    timeRatingEl.textContent = `è©•ä¾¡: ${rating}`;
    gameClear.style.display = "flex";
    restartButton.style.display = "block";
    document.getElementById("thankYouText").style.display = "block";

    // ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢å¾Œã¯startGame()ã§å†ã‚¹ã‚¿ãƒ¼ãƒˆã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹
    restartButton.onclick = () => startGame();
  }
}


  updateUI();
setInterval(() => {
  if (gameStarted && !gameOver) {
    maybeSpawnHeart(); // ãƒãƒ¼ãƒˆç”Ÿæˆ
    maybeSpawnLemon(); // ãƒ¬ãƒ¢ãƒ³ç”Ÿæˆ
    updateStage();
  }
}, 1000);

/* =======================================================
   â–¼ ãƒãƒ¼ãƒˆç”Ÿæˆ
   ======================================================= */
function maybeSpawnHeart() {
  if (lives < maxLives && Math.random() < 0.05) {
    const heart = document.createElement("div");
    heart.classList.add("heal");
    heart.textContent = "ğŸ’—";
    heart.style.left = Math.floor(Math.random() * 9) * 40 + "px";
    heart.style.top = "0px";
    game.appendChild(heart);

    let heartY = 0;
    const heartFall = setInterval(() => {
      if (heartY > 600) {
        heart.remove();
        clearInterval(heartFall);
        return;
      }

      heartY += 5;
      heart.style.top = heartY + "px";

      const heartRect = heart.getBoundingClientRect();
      const playerRect = hitbox.getBoundingClientRect();

      // ğŸ¯ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒå–å¾—ã—ãŸå ´åˆã®ã¿SEã‚’é³´ã‚‰ã™
      if (checkCollision(heartRect, playerRect)) {
        if (lives < maxLives) {
          lives++;
          heart.remove();

          // âœ… ã“ã“ã ã‘ã§é³´ã‚‰ã™
          if (seItem) {
            seItem.currentTime = 0;
            seItem.play().catch(e => console.warn("ã‚¢ã‚¤ãƒ†ãƒ SEå†ç”Ÿã‚¨ãƒ©ãƒ¼:", e));
          }

          updateUI();
          clearInterval(heartFall);
        }
        return;
      }

      // âš ï¸ åå°„ã•ã‚ŒãŸéšœå®³ç‰©ã«å½“ãŸã£ãŸå ´åˆ â†’ ç ´å£Šã€SEã¯é³´ã‚‰ã•ãªã„
      for (let obstacle of allObstacles) {
        const obstacleRect = obstacle.getBoundingClientRect();
        if (checkCollision(heartRect, obstacleRect) && obstacle.dataset.type === "reflected") {
          heart.remove();
          clearInterval(heartFall);

          // ğŸ”¥ ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¨SEã ã‘å‡ºã™ï¼ˆå¿…è¦ãªã‚‰ã“ã“ã« explosion éŸ³ã¨ç”»åƒï¼‰
          createExplosion(
            heartRect.left + heartRect.width / 2 - game.getBoundingClientRect().left,
            heartRect.top + heartRect.height / 2 - game.getBoundingClientRect().top,
            0, // ã‚¹ã‚³ã‚¢ãªã—
            false,
            false // â† çˆ†ç™ºã™ã‚‹
          );

          return;
        }
      }
    }, 30);
  }
}


/* =======================================================
   â–¼ ãƒ¬ãƒ¢ãƒ³ç”Ÿæˆ
   ======================================================= */
function maybeSpawnLemon() {
  if (lives === maxLives && Math.random() < 0.03) {
    const lemon = document.createElement("div");
    lemon.classList.add("heal");
    lemon.textContent = "ğŸ‹";
    lemon.style.left = Math.floor(Math.random() * 9) * 40 + "px";
    lemon.style.top = "0px";
    game.appendChild(lemon);

    let lemonY = 0;
    const lemonFall = setInterval(() => {
      if (lemonY > 600) {
        lemon.remove();
        clearInterval(lemonFall);
        return;
      }

      lemonY += 5;
      lemon.style.top = lemonY + "px";

      const lemonRect = lemon.getBoundingClientRect();
      const gameRect = game.getBoundingClientRect();
      const lemonCenterX = lemonRect.left + lemonRect.width / 2 - gameRect.left;
      const lemonCenterY = lemonRect.top + lemonRect.height / 2 - gameRect.top;

      const playerRect = hitbox.getBoundingClientRect();

      // ğŸ¯ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒãƒ¬ãƒ¢ãƒ³ã‚’å–å¾—ã—ãŸå ´åˆ
      if (checkCollision(lemonRect, playerRect)) {
        const lemonScore = 10000;
        const lemonExp = 300;

        createExplosion(lemonCenterX, lemonCenterY, lemonScore, false, true, lemonExp);

        score += lemonScore;
        addExp(lemonExp);

        // âœ… ã“ã“ã ã‘ã§ã‚¢ã‚¤ãƒ†ãƒ SEã‚’é³´ã‚‰ã™
        if (seItem) {
          seItem.currentTime = 0;
          seItem.play().catch(e => console.warn("ã‚¢ã‚¤ãƒ†ãƒ SEå†ç”Ÿã‚¨ãƒ©ãƒ¼:", e));
        }

        lemon.remove();
        updateUI();
        clearInterval(lemonFall);
        return;
      }

      // âš ï¸ åå°„ã•ã‚ŒãŸéšœå®³ç‰©ã«å½“ãŸã£ãŸå ´åˆã®ã¿ç ´å£Šï¼ˆSEãªã—ï¼‰
      for (let obstacle of allObstacles) {
        const obstacleRect = obstacle.getBoundingClientRect();
        if (checkCollision(lemonRect, obstacleRect) && obstacle.dataset.type === "reflected") {
          lemon.remove();
          clearInterval(lemonFall);

          // ğŸ”¥ çˆ†ç™ºã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¨SEï¼ˆã‚¢ã‚¤ãƒ†ãƒ SEã¯é³´ã‚‰ã•ãªã„ï¼‰
          createExplosion(lemonCenterX, lemonCenterY);
          return;
        }
      }

      // é€šå¸¸éšœå®³ç‰©ã«å½“ãŸã£ã¦ã‚‚æ¶ˆãˆãªã„ï¼ˆç„¡è¦–ï¼‰
    }, 30);
  }
}

// === 1. ã‚¢ã‚»ãƒƒãƒˆèª­ã¿è¾¼ã¿é–¢æ•° ===
function loadImage(src) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = resolve;
    img.onerror = reject;
    img.src = src;
  });
}
/* =======================================================
   â–¼ ã‚¢ã‚¤ãƒ†ãƒ å–å¾—SE
   ======================================================= */
function loadAudio(audioEl) {
  return new Promise((resolve, reject) => {
    audioEl.oncanplaythrough = resolve;
    audioEl.onerror = reject;
    audioEl.load();
  });
}
/* =======================================================
   â–¼ ã‚¹ãƒãƒ›è‡ªå‹•æ‹¡å¤§è¡¨ç¤º
   ======================================================= */
window.addEventListener("load", function () {
  setTimeout(function () {
    window.scrollTo(0, 1);
  }, 100);
});
</script>
</body>
</html>
